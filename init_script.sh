#!/bin/bash
set -x

if [ -z "$1" ] && [ -z "$2" ]; then
  echo >&2 "Error: You need to pass the tenant name and the namespace: './tenant-init.sh <tenantID> <namespace>'"
  exit 1
fi

SECRET_ALG=""
# Check to see if `sha1pass` is installed, otherwise `md5sum` will be used
if ! [ -x "$(command -v sha1pass)" ]; then
  SECRET_ALG="md5sum"
  else
    SECRET_ALG="sha1pass"
fi

NAMESPACE="$2"
kubectl config set-context --current --namespace="$NAMESPACE"

# Get the namespace where all the work will be done
# Define all the needed variables
#
# `TENANT` is the first argument passed to the execution of this script
TENANT="$1"
# `ENTANDO_TENANTS_SECRET` is the name of the secret containing the configuration map for the tenants
ENTANDO_TENANT_SECRET="entando-tenants-secret"
# `TENANT_CONFIG_SECRET="tenant-config-secret" is the name of the secret containing the configuration map for the tenants for the CM
TENANT_CONFIG_SECRET="tenant-config-secret"
# `APP_NAME` is the Entando AppName value
APP_NAME=$(kubectl get enap --no-headers | awk '{print $1}')
if [ ! $? -eq 0 ]; then
  echo >&2 "Error: no resources in this namespace."
  exit 1
fi
# `DEFAULT_ENTANDO_DB` it's the default static value of the DB generated by the Entando's operator
DEFAULT_ENTANDO_DB="default_postgresql_dbms_in_namespace_db"
# `DB_POD` The name of the pod running the instance of Postgresql
DB_POD=$(kubectl get po | grep default-postgresql-dbms-in-namespace-deployment- | awk '{print $1}')
# `PORTDB_SCHEMA` is the name of the schema generated by the Entando's operator
PORTDB_SCHEMA=$(kubectl exec -it $DB_POD -- psql -d $DEFAULT_ENTANDO_DB -c "SELECT schema_name FROM information_schema.schemata WHERE schema_name LIKE '%portdb%' ;" | grep portdb | awk '{print $1}' | tr -d '\r')
# `SERVDB_SCHEMA` is the name of the schema generated by  the Entando's operator
SERVDB_SCHEMA=$(kubectl exec -it $DB_POD -- psql -d $DEFAULT_ENTANDO_DB -c "SELECT schema_name FROM information_schema.schemata WHERE schema_name LIKE '%servdb%' ;" | grep servdb | awk '{print $1}' | tr -d '\r')
# `DE_DB_SCHEMA` is the name of the schema generated by the Entando operator
DE_DB_SCHEMA=$(kubectl exec -it $DB_POD -- psql -d $DEFAULT_ENTANDO_DB -c "SELECT schema_name FROM information_schema.schemata WHERE schema_name LIKE '%dedb%' ;" | grep dedb | awk '{print $1}' | tr -d '\r')
DE_DB_SUFFIX="_cmschema"
# `DB_PASSWORD` The postgres user password
DB_PASSWORD=$(kubectl get secret default-postgresql-dbms-in-namespace-admin-secret --template={{.data.password}} | base64 -d)
# `KC_CLIENT_ID` which is the same of the `APP_NAME`
KC_CLIENT_ID="$APP_NAME"
# `KC_CLIENT_SECRET` is the secret of the `KC_CLIENT_ID` client
# Get the bundle epc menu name and add the -con postfix to be used as the name of the secret
#### old one ####
#### BUNDLE_SECRET_CONF=$(kubectl get eps | grep app-builder-menu-bff | awk '{print $1}')
### New one ###
kubectl get eps | grep app-builder-menu-bff | awk '{print $1}' > BUNDLE_EPC_MENU_NAME.txt
BUNDLE_SECRET_CONF=$(cat BUNDLE_EPC_MENU_NAME.txt | tail -n 1)
#KC_CLIENT_SECRET=$(kubectl get secret $APP_NAME-secret --template={{.data.clientSecret}} | base64 -d)
KC_INTERNAL_URI="http://default-sso-in-namespace-service.$NAMESPACE.svc.cluster.local:8080/auth"
# `KC_AUTH_URL` is the URL of the Keycloak instance
KC_AUTH_URL=$(kubectl get ing default-sso-in-namespace-ingress --no-headers | awk '{print $3}')
# `KC_PROTOCOL` The http protocol to be used (HTTP|HTTPS). We assume that the protocol is the same for each endpoint
KC_PROTOCOL=""
KC_PORT=$(kubectl get ing default-sso-in-namespace-ingress --no-headers | awk '{print $6}')
if [ "$KC_PORT" = "443" ]; then
  KC_PROTOCOL=https
else
  KC_PROTOCOL=http
fi
# `KC_ADMIN` the admin username of KeyCloak
KC_ADMIN=entando_keycloak_admin
# `KC_PASSWORD_ADMIN` The password of the Keycloak admin user
KC_PASSWORD_ADMIN=$(kubectl get secret default-sso-in-namespace-admin-secret --template={{.data.password}} | base64 -d)
# `KC_ADMIN_CLI` The clientID needed to create the realm
KC_ADMIN_CLI=admin-cli
# `KC_GRANT_TYPE` The grant type to pass with the api call
KC_GRANT_TYPE=password
# `KC_APP_NAME_CLIENT_ID_SECRET` the new client secret for the EntandoApp client
KC_APP_NAME_CLIENT_ID_SECRET=$(echo $RANDOM | $SECRET_ALG | tr -dc '[:alnum:]' | head -c 32)
# `KC_DE_APP_NAME_CLIENT_ID_SECRET` the new client secret for the de-app client id
KC_DE_APP_NAME_CLIENT_ID_SECRET=$(echo $RANDOM | $SECRET_ALG | tr -dc '[:alnum:]' | head -c 32)
# `KC_CM_CLIENT_ID_SECRET` the new client secrete for the component manager
KC_CM_CLIENT_ID_SECRET=$(echo $RANDOM | $SECRET_ALG | tr -dc '[:alnum:]' | head -c 32)
# `KC_ENTANDO_APP_BUILDER_MENU_SECRET` The secret of the app-builder EPC menu
KC_ENTANDO_APP_BUILDER_MENU_ID_SECRET=$(kubectl get secret pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server-secret --template={{.data.clientSecret}} | base64 -d)
# `KC_PUB_CERT_ENTANDO` is the public certificate of the new realm
KC_PUB_CERT_ENTANDO=$(curl "$KC_PROTOCOL://$KC_AUTH_URL/auth/realms/entando" | jq '.public_key' | tr -d \")
# `KC_SECRET_CREATION_TIME` The unix time when the secret has been created
KC_SECRET_CREATION_TIME=$(date +%s)
# `SOLR_EXISTS` Check if Solr CRD are already installed
SOLR_EXISTS=false
if kubectl get solr; then
  SOLR_EXISTS=true
else
  SOLR_EXISTS=false
fi
# `SECOND_LEVEL_DNS` is the 2nd level DNS needed for Solr configuration
SECOND_LEVEL_DNS=$(echo "$KC_AUTH_URL" | awk -F . -vOFS=. '{print $(NF-1), $NF}')
# END of variables definition

echo
echo "Your target namespace is: $NAMESPACE"
echo "Your tenant is: $TENANT"
echo "The name of the pod which contains the DB is: $DB_POD"
echo "The name of the portdb schema is: $PORTDB_SCHEMA"
echo "The name of the servdb schema is: $SERVDB_SCHEMA"
echo

# Generate the Keycloak configuration for the tenant if the tenant is not the first one
genRealmConf() {
  cat >"$TENANT"-keycloak-realm.json <<EOF
{
  "realm" : "$TENANT",
  "displayName" : "$TENANT",
  "notBefore" : 0,
  "defaultSignatureAlgorithm" : "RS256",
  "revokeRefreshToken" : false,
  "refreshTokenMaxReuse" : 0,
  "accessTokenLifespan" : 300,
  "accessTokenLifespanForImplicitFlow" : 900,
  "ssoSessionIdleTimeout" : 1800,
  "ssoSessionMaxLifespan" : 36000,
  "ssoSessionIdleTimeoutRememberMe" : 0,
  "ssoSessionMaxLifespanRememberMe" : 0,
  "offlineSessionIdleTimeout" : 2592000,
  "offlineSessionMaxLifespanEnabled" : false,
  "offlineSessionMaxLifespan" : 5184000,
  "clientSessionIdleTimeout" : 0,
  "clientSessionMaxLifespan" : 0,
  "clientOfflineSessionIdleTimeout" : 0,
  "clientOfflineSessionMaxLifespan" : 0,
  "accessCodeLifespan" : 60,
  "accessCodeLifespanUserAction" : 300,
  "accessCodeLifespanLogin" : 1800,
  "actionTokenGeneratedByAdminLifespan" : 43200,
  "actionTokenGeneratedByUserLifespan" : 300,
  "oauth2DeviceCodeLifespan" : 600,
  "oauth2DevicePollingInterval" : 5,
  "enabled" : true,
  "sslRequired" : "none",
  "registrationAllowed" : false,
  "registrationEmailAsUsername" : false,
  "rememberMe" : false,
  "verifyEmail" : false,
  "loginWithEmailAllowed" : true,
  "duplicateEmailsAllowed" : false,
  "resetPasswordAllowed" : false,
  "editUsernameAllowed" : false,
  "bruteForceProtected" : false,
  "permanentLockout" : false,
  "maxFailureWaitSeconds" : 900,
  "minimumQuickLoginWaitSeconds" : 60,
  "waitIncrementSeconds" : 60,
  "quickLoginCheckMilliSeconds" : 1000,
  "maxDeltaTimeSeconds" : 43200,
  "failureFactor" : 30,
  "roles" : {
    "realm" : [ {
      "name" : "uma_authorization",
      "description" : "\${role_uma_authorization}",
      "composite" : false,
      "clientRole" : false,
      "containerId" : "d375e04d-1876-4541-885d-432faccad06d",
      "attributes" : { }
    }, {
      "name" : "default-roles-entando",
      "description" : "\${role_default-roles}",
      "composite" : true,
      "composites" : {
        "realm" : [ "offline_access", "uma_authorization" ],
        "client" : {
          "account" : [ "manage-account", "view-profile" ]
        }
      },
      "clientRole" : false,
      "containerId" : "d375e04d-1876-4541-885d-432faccad06d",
      "attributes" : { }
    }, {
      "name" : "offline_access",
      "description" : "\${role_offline-access}",
      "composite" : false,
      "clientRole" : false,
      "containerId" : "d375e04d-1876-4541-885d-432faccad06d",
      "attributes" : { }
    } ],
    "client" : {
      "pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server" : [ {
        "name" : "entandoApp",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "1328b2d7-23c6-4dd0-83eb-27a80078200f",
        "attributes" : { }
      } ],
      "realm-management" : [ {
        "name" : "manage-users",
        "description" : "\${role_manage-users}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "view-authorization",
        "description" : "\${role_view-authorization}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "create-client",
        "description" : "\${role_create-client}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "view-identity-providers",
        "description" : "\${role_view-identity-providers}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "query-users",
        "description" : "\${role_query-users}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "manage-realm",
        "description" : "\${role_manage-realm}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "manage-identity-providers",
        "description" : "\${role_manage-identity-providers}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "query-groups",
        "description" : "\${role_query-groups}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "query-realms",
        "description" : "\${role_query-realms}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "manage-authorization",
        "description" : "\${role_manage-authorization}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "view-users",
        "description" : "\${role_view-users}",
        "composite" : true,
        "composites" : {
          "client" : {
            "realm-management" : [ "query-groups", "query-users" ]
          }
        },
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "realm-admin",
        "description" : "\${role_realm-admin}",
        "composite" : true,
        "composites" : {
          "client" : {
            "realm-management" : [ "manage-users", "view-authorization", "create-client", "view-identity-providers", "query-users", "manage-realm", "manage-identity-providers", "query-groups", "query-realms", "view-users", "manage-authorization", "view-realm", "view-clients", "manage-clients", "query-clients", "view-events", "impersonation", "manage-events" ]
          }
        },
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "view-realm",
        "description" : "\${role_view-realm}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "manage-clients",
        "description" : "\${role_manage-clients}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "view-clients",
        "description" : "\${role_view-clients}",
        "composite" : true,
        "composites" : {
          "client" : {
            "realm-management" : [ "query-clients" ]
          }
        },
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "query-clients",
        "description" : "\${role_query-clients}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "view-events",
        "description" : "\${role_view-events}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "impersonation",
        "description" : "\${role_impersonation}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      }, {
        "name" : "manage-events",
        "description" : "\${role_manage-events}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "d8faa5d5-eb1b-42c3-bf73-18e4d5262af4",
        "attributes" : { }
      } ],
      "$APP_NAME-de" : [ ],
      "security-admin-console" : [ ],
      "admin-cli" : [ ],
      "account-console" : [ ],
      "entando-web" : [ ],
      "$APP_NAME" : [ {
        "name" : "superuser",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "87b65e94-8039-499c-94cc-2caf3d339a86",
        "attributes" : { }
      } ],
      "broker" : [ {
        "name" : "read-token",
        "description" : "\${role_read-token}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "6df1698b-8c27-4128-bf94-f995f0034a73",
        "attributes" : { }
      } ],
      "account" : [ {
        "name" : "manage-consent",
        "description" : "\${role_manage-consent}",
        "composite" : true,
        "composites" : {
          "client" : {
            "account" : [ "view-consent" ]
          }
        },
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      }, {
        "name" : "delete-account",
        "description" : "\${role_delete-account}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      }, {
        "name" : "manage-account",
        "description" : "\${role_manage-account}",
        "composite" : true,
        "composites" : {
          "client" : {
            "account" : [ "manage-account-links" ]
          }
        },
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      }, {
        "name" : "view-applications",
        "description" : "\${role_view-applications}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      }, {
        "name" : "view-consent",
        "description" : "\${role_view-consent}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      }, {
        "name" : "manage-account-links",
        "description" : "\${role_manage-account-links}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      }, {
        "name" : "view-profile",
        "description" : "\${role_view-profile}",
        "composite" : false,
        "clientRole" : true,
        "containerId" : "fd5bc756-6a88-49e0-a81c-a80152de0d03",
        "attributes" : { }
      } ]
    }
  },
  "groups" : [ ],
  "defaultRole" : {
    "name" : "default-roles-entando",
    "description" : "\${role_default-roles}",
    "composite" : true,
    "clientRole" : false,
    "containerId" : "d375e04d-1876-4541-885d-432faccad06d"
  },
  "requiredCredentials" : [ "password" ],
  "otpPolicyType" : "totp",
  "otpPolicyAlgorithm" : "HmacSHA1",
  "otpPolicyInitialCounter" : 0,
  "otpPolicyDigits" : 6,
  "otpPolicyLookAheadWindow" : 1,
  "otpPolicyPeriod" : 30,
  "otpSupportedApplications" : [ "FreeOTP", "Google Authenticator" ],
  "webAuthnPolicyRpEntityName" : "keycloak",
  "webAuthnPolicySignatureAlgorithms" : [ "ES256" ],
  "webAuthnPolicyRpId" : "",
  "webAuthnPolicyAttestationConveyancePreference" : "not specified",
  "webAuthnPolicyAuthenticatorAttachment" : "not specified",
  "webAuthnPolicyRequireResidentKey" : "not specified",
  "webAuthnPolicyUserVerificationRequirement" : "not specified",
  "webAuthnPolicyCreateTimeout" : 0,
  "webAuthnPolicyAvoidSameAuthenticatorRegister" : false,
  "webAuthnPolicyAcceptableAaguids" : [ ],
  "webAuthnPolicyPasswordlessRpEntityName" : "keycloak",
  "webAuthnPolicyPasswordlessSignatureAlgorithms" : [ "ES256" ],
  "webAuthnPolicyPasswordlessRpId" : "",
  "webAuthnPolicyPasswordlessAttestationConveyancePreference" : "not specified",
  "webAuthnPolicyPasswordlessAuthenticatorAttachment" : "not specified",
  "webAuthnPolicyPasswordlessRequireResidentKey" : "not specified",
  "webAuthnPolicyPasswordlessUserVerificationRequirement" : "not specified",
  "webAuthnPolicyPasswordlessCreateTimeout" : 0,
  "webAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister" : false,
  "webAuthnPolicyPasswordlessAcceptableAaguids" : [ ],
  "users" : [ {
    "createdTimestamp" : 1685028387896,
    "username" : "admin",
    "enabled" : true,
    "totp" : false,
    "emailVerified" : false,
    "credentials" : [ {
      "type" : "password",
      "createdDate" : 1685028387981,
      "secretData" : "{\"value\":\"PId0NuMslD2hQMCGptphhQx0+3dyKcEPqyZS31BFBe6W0A68Q6JtiPrffiOLg02ZiwcfBsBYWOaXk2pnWJe0qQ==\",\"salt\":\"SzPS46gsvvQQGRSEGPbwMQ==\",\"additionalParameters\":{}}",
      "credentialData" : "{\"hashIterations\":27500,\"algorithm\":\"pbkdf2-sha256\",\"additionalParameters\":{}}"
    } ],
    "disableableCredentialTypes" : [ ],
    "requiredActions" : [ "UPDATE_PASSWORD" ],
    "realmRoles" : [ "default-roles-entando" ],
    "notBefore" : 0,
    "groups" : [ ]
  }, {
    "createdTimestamp" : 1685028390667,
    "username" : "service-account-$APP_NAME",
    "enabled" : true,
    "totp" : false,
    "emailVerified" : false,
    "serviceAccountClientId" : "$APP_NAME",
    "credentials" : [ ],
    "disableableCredentialTypes" : [ ],
    "requiredActions" : [ ],
    "realmRoles" : [ "default-roles-entando" ],
    "clientRoles" : {
      "pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server" : [ "entandoApp" ],
      "realm-management" : [ "realm-admin" ]
    },
    "notBefore" : 0,
    "groups" : [ ]
  }, {
    "createdTimestamp" : 1685028390485,
    "username" : "service-account-$APP_NAME-de",
    "enabled" : true,
    "totp" : false,
    "emailVerified" : false,
    "serviceAccountClientId" : "$APP_NAME-de",
    "credentials" : [ ],
    "disableableCredentialTypes" : [ ],
    "requiredActions" : [ ],
    "realmRoles" : [ "default-roles-entando" ],
    "clientRoles" : {
      "pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server" : [ "entandoApp" ],
      "$APP_NAME" : [ "superuser" ]
    },
    "notBefore" : 0,
    "groups" : [ ]
  }, {
    "createdTimestamp" : 1685029566026,
    "username" : "service-account-pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server",
    "enabled" : true,
    "totp" : false,
    "emailVerified" : false,
    "serviceAccountClientId" : "pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server",
    "credentials" : [ ],
    "disableableCredentialTypes" : [ ],
    "requiredActions" : [ ],
    "realmRoles" : [ "default-roles-entando" ],
    "notBefore" : 0,
    "groups" : [ ]
  } ],
  "scopeMappings" : [ {
    "clientScope" : "offline_access",
    "roles" : [ "offline_access" ]
  } ],
  "clientScopeMappings" : {
    "account" : [ {
      "client" : "account-console",
      "roles" : [ "manage-account" ]
    } ]
  },
  "clients" : [ {
    "clientId" : "account",
    "name" : "\${client_account}",
    "rootUrl" : "\${authBaseUrl}",
    "baseUrl" : "/realms/$TENANT/account/",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ "/realms/$TENANT/account/*" ],
    "webOrigins" : [ ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : false,
    "directAccessGrantsEnabled" : false,
    "serviceAccountsEnabled" : false,
    "publicClient" : true,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : { },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : false,
    "nodeReRegistrationTimeout" : 0,
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "account-console",
    "name" : "\${client_account-console}",
    "rootUrl" : "\${authBaseUrl}",
    "baseUrl" : "/realms/$TENANT/account/",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ "/realms/$TENANT/account/*" ],
    "webOrigins" : [ ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : false,
    "directAccessGrantsEnabled" : false,
    "serviceAccountsEnabled" : false,
    "publicClient" : true,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : {
      "pkce.code.challenge.method" : "S256"
    },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : false,
    "nodeReRegistrationTimeout" : 0,
    "protocolMappers" : [ {
      "name" : "audience resolve",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-audience-resolve-mapper",
      "consentRequired" : false,
      "config" : { }
    } ],
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "admin-cli",
    "name" : "\${client_admin-cli}",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ ],
    "webOrigins" : [ ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : false,
    "implicitFlowEnabled" : false,
    "directAccessGrantsEnabled" : true,
    "serviceAccountsEnabled" : false,
    "publicClient" : true,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : { },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : false,
    "nodeReRegistrationTimeout" : 0,
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "broker",
    "name" : "\${client_broker}",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ ],
    "webOrigins" : [ ],
    "notBefore" : 0,
    "bearerOnly" : true,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : false,
    "directAccessGrantsEnabled" : false,
    "serviceAccountsEnabled" : false,
    "publicClient" : false,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : { },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : false,
    "nodeReRegistrationTimeout" : 0,
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "entando-web",
    "name" : "Entando WEB",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ "$KC_PROTOCOL://$TENANT.$KC_AUTH_URL/*" ],
    "webOrigins" : [ "$KC_PROTOCOL://$TENANT.$KC_AUTH_URL" ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : true,
    "directAccessGrantsEnabled" : false,
    "serviceAccountsEnabled" : false,
    "publicClient" : true,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : { },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : true,
    "nodeReRegistrationTimeout" : -1,
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "$APP_NAME",
    "name" : "$APP_NAME",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "secret" : "$KC_APP_NAME_CLIENT_ID_SECRET",
    "redirectUris" : [ "$KC_PROTOCOL://$TENANT.$KC_AUTH_URL/entando-de-app/*" ],
    "webOrigins" : [ "$KC_PROTOCOL://$TENANT.$KC_AUTH_URL" ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : true,
    "directAccessGrantsEnabled" : true,
    "serviceAccountsEnabled" : true,
    "publicClient" : false,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : {
      "client.secret.creation.time" : "$KC_SECRET_CREATION_TIME"
    },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : true,
    "nodeReRegistrationTimeout" : -1,
    "protocolMappers" : [ {
      "name" : "Client Host",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientHost",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientHost",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "Client ID",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientId",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientId",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "Client IP Address",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientAddress",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientAddress",
        "jsonType.label" : "String"
      }
    } ],
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "$APP_NAME-de",
    "name" : "$APP_NAME-de",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "secret" : "$KC_CM_CLIENT_ID_SECRET",
    "redirectUris" : [ "$KC_PROTOCOL://$TENANT.$KC_AUTH_URL/digital-exchange/*" ],
    "webOrigins" : [ "$KC_PROTOCOL://$TENANT.$KC_AUTH_URL" ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : true,
    "directAccessGrantsEnabled" : true,
    "serviceAccountsEnabled" : true,
    "publicClient" : false,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : {
      "client.secret.creation.time" : "$KC_SECRET_CREATION_TIME"
    },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : true,
    "nodeReRegistrationTimeout" : -1,
    "protocolMappers" : [ {
      "name" : "Client ID",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientId",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientId",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "Client IP Address",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientAddress",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientAddress",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "Client Host",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientHost",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientHost",
        "jsonType.label" : "String"
      }
    } ],
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-server",
    "name" : "pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "secret" : "$KC_ENTANDO_APP_BUILDER_MENU_ID_SECRET",
    "redirectUris" : [ ],
    "webOrigins" : [ ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : true,
    "directAccessGrantsEnabled" : true,
    "serviceAccountsEnabled" : true,
    "publicClient" : false,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : {
      "client.secret.creation.time" : "$KC_SECRET_CREATION_TIME"
    },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : true,
    "nodeReRegistrationTimeout" : -1,
    "protocolMappers" : [ {
      "name" : "Client Host",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientHost",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientHost",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "Client IP Address",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientAddress",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientAddress",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "Client ID",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usersessionmodel-note-mapper",
      "consentRequired" : false,
      "config" : {
        "user.session.note" : "clientId",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "clientId",
        "jsonType.label" : "String"
      }
    } ],
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "realm-management",
    "name" : "\${client_realm-management}",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ ],
    "webOrigins" : [ ],
    "notBefore" : 0,
    "bearerOnly" : true,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : false,
    "directAccessGrantsEnabled" : false,
    "serviceAccountsEnabled" : false,
    "publicClient" : false,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : { },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : false,
    "nodeReRegistrationTimeout" : 0,
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  }, {
    "clientId" : "security-admin-console",
    "name" : "\${client_security-admin-console}",
    "rootUrl" : "\${authAdminUrl}",
    "baseUrl" : "/admin/$TENANT/console/",
    "surrogateAuthRequired" : false,
    "enabled" : true,
    "alwaysDisplayInConsole" : false,
    "clientAuthenticatorType" : "client-secret",
    "redirectUris" : [ "/admin/$TENANT/console/*" ],
    "webOrigins" : [ "+" ],
    "notBefore" : 0,
    "bearerOnly" : false,
    "consentRequired" : false,
    "standardFlowEnabled" : true,
    "implicitFlowEnabled" : false,
    "directAccessGrantsEnabled" : false,
    "serviceAccountsEnabled" : false,
    "publicClient" : true,
    "frontchannelLogout" : false,
    "protocol" : "openid-connect",
    "attributes" : {
      "pkce.code.challenge.method" : "S256"
    },
    "authenticationFlowBindingOverrides" : { },
    "fullScopeAllowed" : false,
    "nodeReRegistrationTimeout" : 0,
    "protocolMappers" : [ {
      "name" : "locale",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "locale",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "locale",
        "jsonType.label" : "String"
      }
    } ],
    "defaultClientScopes" : [ "web-origins", "acr", "profile", "roles", "email" ],
    "optionalClientScopes" : [ "address", "phone", "offline_access", "microprofile-jwt" ]
  } ],
  "clientScopes" : [ {
    "name" : "role_list",
    "description" : "SAML role list",
    "protocol" : "saml",
    "attributes" : {
      "consent.screen.text" : "\${samlRoleListScopeConsentText}",
      "display.on.consent.screen" : "true"
    },
    "protocolMappers" : [ {
      "name" : "role list",
      "protocol" : "saml",
      "protocolMapper" : "saml-role-list-mapper",
      "consentRequired" : false,
      "config" : {
        "single" : "false",
        "attribute.nameformat" : "Basic",
        "attribute.name" : "Role"
      }
    } ]
  }, {
    "name" : "email",
    "description" : "OpenID Connect built-in scope: email",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "true",
      "display.on.consent.screen" : "true",
      "consent.screen.text" : "\${emailScopeConsentText}"
    },
    "protocolMappers" : [ {
      "name" : "email",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-property-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "email",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "email",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "email verified",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-property-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "emailVerified",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "email_verified",
        "jsonType.label" : "boolean"
      }
    } ]
  }, {
    "name" : "phone",
    "description" : "OpenID Connect built-in scope: phone",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "true",
      "display.on.consent.screen" : "true",
      "consent.screen.text" : "\${phoneScopeConsentText}"
    },
    "protocolMappers" : [ {
      "name" : "phone number",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "phoneNumber",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "phone_number",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "phone number verified",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "phoneNumberVerified",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "phone_number_verified",
        "jsonType.label" : "boolean"
      }
    } ]
  }, {
    "name" : "offline_access",
    "description" : "OpenID Connect built-in scope: offline_access",
    "protocol" : "openid-connect",
    "attributes" : {
      "consent.screen.text" : "\${offlineAccessScopeConsentText}",
      "display.on.consent.screen" : "true"
    }
  }, {
    "name" : "address",
    "description" : "OpenID Connect built-in scope: address",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "true",
      "display.on.consent.screen" : "true",
      "consent.screen.text" : "\${addressScopeConsentText}"
    },
    "protocolMappers" : [ {
      "name" : "address",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-address-mapper",
      "consentRequired" : false,
      "config" : {
        "user.attribute.formatted" : "formatted",
        "user.attribute.country" : "country",
        "user.attribute.postal_code" : "postal_code",
        "userinfo.token.claim" : "true",
        "user.attribute.street" : "street",
        "id.token.claim" : "true",
        "user.attribute.region" : "region",
        "access.token.claim" : "true",
        "user.attribute.locality" : "locality"
      }
    } ]
  }, {
    "name" : "acr",
    "description" : "OpenID Connect scope for add acr (authentication context class reference) to the token",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "false",
      "display.on.consent.screen" : "false"
    },
    "protocolMappers" : [ {
      "name" : "acr loa level",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-acr-mapper",
      "consentRequired" : false,
      "config" : {
        "id.token.claim" : "true",
        "access.token.claim" : "true"
      }
    } ]
  }, {
    "name" : "profile",
    "description" : "OpenID Connect built-in scope: profile",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "true",
      "display.on.consent.screen" : "true",
      "consent.screen.text" : "\${profileScopeConsentText}"
    },
    "protocolMappers" : [ {
      "name" : "full name",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-full-name-mapper",
      "consentRequired" : false,
      "config" : {
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "userinfo.token.claim" : "true"
      }
    }, {
      "name" : "profile",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "profile",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "profile",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "birthdate",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "birthdate",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "birthdate",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "locale",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "locale",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "locale",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "updated at",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "updatedAt",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "updated_at",
        "jsonType.label" : "long"
      }
    }, {
      "name" : "picture",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "picture",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "picture",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "username",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-property-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "username",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "preferred_username",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "middle name",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "middleName",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "middle_name",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "family name",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-property-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "lastName",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "family_name",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "zoneinfo",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "zoneinfo",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "zoneinfo",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "given name",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-property-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "firstName",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "given_name",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "nickname",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "nickname",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "nickname",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "gender",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "gender",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "gender",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "website",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-attribute-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "website",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "website",
        "jsonType.label" : "String"
      }
    } ]
  }, {
    "name" : "roles",
    "description" : "OpenID Connect scope for add user roles to the access token",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "false",
      "display.on.consent.screen" : "true",
      "consent.screen.text" : "\${rolesScopeConsentText}"
    },
    "protocolMappers" : [ {
      "name" : "audience resolve",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-audience-resolve-mapper",
      "consentRequired" : false,
      "config" : { }
    }, {
      "name" : "realm roles",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-realm-role-mapper",
      "consentRequired" : false,
      "config" : {
        "user.attribute" : "foo",
        "access.token.claim" : "true",
        "claim.name" : "realm_access.roles",
        "jsonType.label" : "String",
        "multivalued" : "true"
      }
    }, {
      "name" : "client roles",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-client-role-mapper",
      "consentRequired" : false,
      "config" : {
        "user.attribute" : "foo",
        "access.token.claim" : "true",
        "claim.name" : "resource_access.\${client_id}.roles",
        "jsonType.label" : "String",
        "multivalued" : "true"
      }
    } ]
  }, {
    "name" : "microprofile-jwt",
    "description" : "Microprofile - JWT built-in scope",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "true",
      "display.on.consent.screen" : "false"
    },
    "protocolMappers" : [ {
      "name" : "groups",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-realm-role-mapper",
      "consentRequired" : false,
      "config" : {
        "multivalued" : "true",
        "user.attribute" : "foo",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "groups",
        "jsonType.label" : "String"
      }
    }, {
      "name" : "upn",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-usermodel-property-mapper",
      "consentRequired" : false,
      "config" : {
        "userinfo.token.claim" : "true",
        "user.attribute" : "username",
        "id.token.claim" : "true",
        "access.token.claim" : "true",
        "claim.name" : "upn",
        "jsonType.label" : "String"
      }
    } ]
  }, {
    "name" : "web-origins",
    "description" : "OpenID Connect scope for add allowed web origins to the access token",
    "protocol" : "openid-connect",
    "attributes" : {
      "include.in.token.scope" : "false",
      "display.on.consent.screen" : "false",
      "consent.screen.text" : ""
    },
    "protocolMappers" : [ {
      "name" : "allowed web origins",
      "protocol" : "openid-connect",
      "protocolMapper" : "oidc-allowed-origins-mapper",
      "consentRequired" : false,
      "config" : { }
    } ]
  } ],
  "defaultDefaultClientScopes" : [ "role_list", "profile", "email", "roles", "web-origins", "acr" ],
  "defaultOptionalClientScopes" : [ "offline_access", "address", "phone", "microprofile-jwt" ],
  "browserSecurityHeaders" : {
    "contentSecurityPolicyReportOnly" : "",
    "xContentTypeOptions" : "nosniff",
    "xRobotsTag" : "none",
    "xFrameOptions" : "SAMEORIGIN",
    "contentSecurityPolicy" : "frame-src 'self'; frame-ancestors 'self'; object-src 'none';",
    "xXSSProtection" : "1; mode=block",
    "strictTransportSecurity" : "max-age=31536000; includeSubDomains"
  },
  "smtpServer" : { },
  "eventsEnabled" : false,
  "eventsListeners" : [ "jboss-logging" ],
  "enabledEventTypes" : [ ],
  "adminEventsEnabled" : false,
  "adminEventsDetailsEnabled" : false,
  "identityProviders" : [ ],
  "identityProviderMappers" : [ ],
  "components" : {
    "org.keycloak.services.clientregistration.policy.ClientRegistrationPolicy" : [ {
      "name" : "Trusted Hosts",
      "providerId" : "trusted-hosts",
      "subType" : "anonymous",
      "subComponents" : { },
      "config" : {
        "host-sending-registration-request-must-match" : [ "true" ],
        "client-uris-must-match" : [ "true" ]
      }
    }, {
      "name" : "Allowed Protocol Mapper Types",
      "providerId" : "allowed-protocol-mappers",
      "subType" : "anonymous",
      "subComponents" : { },
      "config" : {
        "allowed-protocol-mapper-types" : [ "saml-role-list-mapper", "oidc-sha256-pairwise-sub-mapper", "saml-user-attribute-mapper", "saml-user-property-mapper", "oidc-usermodel-property-mapper", "oidc-full-name-mapper", "oidc-address-mapper", "oidc-usermodel-attribute-mapper" ]
      }
    }, {
      "name" : "Allowed Protocol Mapper Types",
      "providerId" : "allowed-protocol-mappers",
      "subType" : "authenticated",
      "subComponents" : { },
      "config" : {
        "allowed-protocol-mapper-types" : [ "oidc-usermodel-attribute-mapper", "saml-user-attribute-mapper", "oidc-usermodel-property-mapper", "saml-role-list-mapper", "oidc-address-mapper", "saml-user-property-mapper", "oidc-full-name-mapper", "oidc-sha256-pairwise-sub-mapper" ]
      }
    }, {
      "name" : "Full Scope Disabled",
      "providerId" : "scope",
      "subType" : "anonymous",
      "subComponents" : { },
      "config" : { }
    }, {
      "name" : "Consent Required",
      "providerId" : "consent-required",
      "subType" : "anonymous",
      "subComponents" : { },
      "config" : { }
    }, {
      "name" : "Max Clients Limit",
      "providerId" : "max-clients",
      "subType" : "anonymous",
      "subComponents" : { },
      "config" : {
        "max-clients" : [ "200" ]
      }
    }, {
      "name" : "Allowed Client Scopes",
      "providerId" : "allowed-client-templates",
      "subType" : "anonymous",
      "subComponents" : { },
      "config" : {
        "allow-default-scopes" : [ "true" ]
      }
    }, {
      "name" : "Allowed Client Scopes",
      "providerId" : "allowed-client-templates",
      "subType" : "authenticated",
      "subComponents" : { },
      "config" : {
        "allow-default-scopes" : [ "true" ]
      }
    } ],
    "org.keycloak.keys.KeyProvider" : [ {
      "name" : "hmac-generated",
      "providerId" : "hmac-generated",
      "subComponents" : { },
      "config" : {
        "kid" : [ "1304a6fa-1df7-4032-9719-5173fdc874ff" ],
        "secret" : [ "fZsPERDhStUsdTshiouitPCv8bA_cXyKDAeFcQ9KEngF5eCiwEf_kXjTx6Rfo7UZV5yfH4tpXtt_BNEkE0XHDw" ],
        "priority" : [ "100" ],
        "algorithm" : [ "HS256" ]
      }
    }, {
      "name" : "rsa-enc-generated",
      "providerId" : "rsa-enc-generated",
      "subComponents" : { },
      "config" : {
        "privateKey" : [ "MIIEpAIBAAKCAQEA3qWxaF/qHdUIZqN9C8M51evnhkxuow7NpuUkRmvXTBbN7d+l/+pAJqEQTwzHkrUkDaaeC1xdZeijiQvmJ7WvFOcBVrJytuMmddGcOHF5qMJPEFyh/f62rM5Cr0yu8FgAUZT/fd1i6wQ1V6TgzzVtpAT6nCnZUulaQB4DZ7aotnOtLLZZEWLImi9KLu3FKrDueNozIrFGf5blvW9GksNCmtwk75J+vxgPm346EaNnaRVGv76uwOmKnLeNoOjxoYNzrVb5+pslt3MeYll+QVyOId+IEL4GeTRx5Cf3HQXVDr58AKZdQAxt44peN7dHP92gcMbP15OPl1wBocIURKq6lwIDAQABAoIBADsA/jsC8DBnvIo22XS8kB85HWph5xAfZDDOmQZwneX0RS69Dmj703RpSsEoSdt/VcaoWUn5eGcBeBVhqeTsKTII5jnroKsHF7Ixko0CxZMLq5hSdDuzvQWew91hHRtktvDn462fdg+CVgCcGVfQePX2u9OW45ktblV/nrdlmOCA2NdYGlpyuBq0SZoF07YAKi4g6Zs6oi1+0jibtg8z1goZcNJVYDhesGQV/wVDVRXrNlgit+Yv4REqrIrOYjwD7KpU3tc+WppN0731sYQOHsGTXMtzsqaXsQmFFHIUs3EQfNJBA+JOsF5j7UVI2qoZ6jtLqICtOnFZIPjGh6yv5cECgYEA9Nl3pQJbDTXlV3XmekrxarffFSbD2nJ6wkX8xu/J439Xq2FQQu/z8xrI3EHypLUqb/A3YuURLcg+49OCwCdcmhK3cyV8Wdtq7IIqRK2fDzyjE+2DKLJFKBQf/6njljzVP2UBmV63GfeZyXARcC+rrEK5yK5soSFxsCIvMwmvn4UCgYEA6MlihoE3zg+PGkANk1ZRBdexikopmTY/otOSWygxioggrFKeaGpWVUxga3EV5kusZcu9TWDcJaEBAqG59WvpKzqdgTrOlbm2JxbglNHjbIE139BxueVw4rwDR6V3xcBIi7DIZ2IuBYyZRJPo0XpA+8SLna2bgaStFa+S34g5NmsCgYEA7f5rs3KEumSG1ep96qTp4Ed1iYOyn6Ti+e85cs0lOgJPXwAqGcZPIyAH2UAo8DxAUan2zCPH/O5FYwH2d3xLIF/M/RmUs2r5lYY4O6VflFnmUbpt4KLXYcueBs5Fr4TV6tbtJPzRkWYAj7Jk4N0VS01YdF5GrKBrdz7jDgL+OFkCgYAtMgxC+QuQokyyWAVKudN5QuthYgy5hmLMhi9AK4mSz+MoEdJXi22/mdiOg6Iw2DhcezYBs/CKDbxYenXURGM81WCHGpfJUgkfhb2Mp0N0aZHAJoQuB3HnU4F/g4zBhBeRp30BNXqh8S5AtkbZhNbhCsPglTg/72z7bN8jLxuMiQKBgQCtSTpfOsqEV7QXT7w5uAQFRM+eqPsGk/WgR0p15eVmjeW1yZjvgkt9I64C74fqDnP7XoE1RkQ7Hc8Pw3uRrxgiqc89kbXJW4lbQoKkqPE3Bpo0M94LwdqFMu88VF+5XzEMkdqMI6UXtijQNQF3pAVrkIw4YniGSZkarZQYx5j0/g==" ],
        "keyUse" : [ "ENC" ],
        "certificate" : [ "MIICnTCCAYUCBgGIU4S7MzANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdlbnRhbmRvMB4XDTIzMDUyNTE1MjQ0N1oXDTMzMDUyNTE1MjYyN1owEjEQMA4GA1UEAwwHZW50YW5kbzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAN6lsWhf6h3VCGajfQvDOdXr54ZMbqMOzablJEZr10wWze3fpf/qQCahEE8Mx5K1JA2mngtcXWXoo4kL5ie1rxTnAVaycrbjJnXRnDhxeajCTxBcof3+tqzOQq9MrvBYAFGU/33dYusENVek4M81baQE+pwp2VLpWkAeA2e2qLZzrSy2WRFiyJovSi7txSqw7njaMyKxRn+W5b1vRpLDQprcJO+Sfr8YD5t+OhGjZ2kVRr++rsDpipy3jaDo8aGDc61W+fqbJbdzHmJZfkFcjiHfiBC+Bnk0ceQn9x0F1Q6+fACmXUAMbeOKXje3Rz/doHDGz9eTj5dcAaHCFESqupcCAwEAATANBgkqhkiG9w0BAQsFAAOCAQEAXSfD0VNyoyaJxhJ9NcsSQuZ1fj0pLxFywN1+qNryvnr/WoD13224wUget8z7gCzy+iXekI2E/Rf0Vlxny30CRGRJQd0r5hhtuDToF7WvSQzVbpLlp/MgRxGDLpa61b2S709SO6CoPmDJTKMwicUBB9yZIQa05rHsn4OiHIiR9q+3DzxL1AoHwxI5cwVeL7oBDhSiezh8D/tFcHLMI3LfFRtBZnwC/1PHbeWtE3q2Awf3OzSFBkOtIFagVyUwfP2GvT8kETXk6dtxBh+pkvExDWzJ5mfiTPBKmuRpcWNJEOBDmfwHv+dFMSmf+vN9BpshqTq+4u4BgtenW4LhOjn1ng==" ],
        "priority" : [ "100" ],
        "algorithm" : [ "RSA-OAEP" ]
      }
    }, {
      "name" : "aes-generated",
      "providerId" : "aes-generated",
      "subComponents" : { },
      "config" : {
        "kid" : [ "e05c7ee9-483c-48ff-8841-da9a52278658" ],
        "secret" : [ "OGLv2zolvg2hQrhvZljAfw" ],
        "priority" : [ "100" ]
      }
    }, {
      "name" : "rsa-generated",
      "providerId" : "rsa-generated",
      "subComponents" : { },
      "config" : {
        "privateKey" : [ "MIIEpAIBAAKCAQEAmmIR/9STliMr+Hyl8+hgoGlxuOfO4RvS/eh5ukpGq4Ihd8X+LxWV3bFFhCZCZNO0qI2VBdlX2TushPuiE+mWEXg8kWqTF/f+bPVYA0oVCAmpmB83pQAHN7mHEwQfqAylZaM2D/ZSUfRetqrTJfWI6w9xlRiMV2Wleqr4ju6T4Efi5preXSdqCVfriGqVfrisXF05cFpWwwx4FbQz6KcWls/VsTtckjz/RcjxLnvi2Q5G4Lx/ZyXsGMuZjsC5Db6uKGgrjdWctTH77ZUhpropa2to5bHVW0WHSrUU5r/JhKIY559gSwfTceQIbSPft0bBT/12QMmJtH+J9E+/u4rliQIDAQABAoIBAGIgo8Awpf5wLKqsz+7QbVqIqzgUX3LF9L5e3cCDJZguBofS2VWkKrXWz5DHoLvltJbOJ0KoeyYgv+9m4gY2GqTP/++OBiDeCGHJMEAm/mc1fQ6sCPpfojbRPgHgRR7Tqu2HZ/2NW5Wr9ee1fLBL+NMv5coW6F1ExoHJ2mM/Uc7j5DgmZlRz07pVrOJV6ea6h9DwQhzaNO8Tgjw5iyN7R1HO5J0/U1ZyDZuB/YJj9vI/BgTEf0f+ppPhqlENGSTdDhUBvrdGoKlzRIdIQQm/JgyBAQuJlE6G08T9E/wca96yu/5i1pT2kFusic7FEYomf1lPlfNfahNBnczKtWiYoAECgYEA3QV415AFVKn39nvJS1QbVW86sXJrtwyFl2y6nSMLDaXDglc+ltLtxY8qJnqbLpCSar1NO+LjcO2c8TByZe8rfJDUCKDEQJaVSeDa+pwJPSx99XIgMW0SYLlki6OvtRhQVIhvMjlbn+KP1PKtYwIEqblnahhgqxzmZDXgdUNDfYECgYEAstDLT0CbhNcIZl+m3lHrRjz6S7vgpnDPCwqkStS2d9/zKbuaouc/RW31HlqV90Gc/sax21vCwqNv9ZbZTKq0gltaZPKjxbmBa+zjZk3l39V5rvY7dK7CG27YUqH/Q/7KDmgksa8Q6C1DvxXhBl+pkwqrlgvceJvBKTH359/hfAkCgYEA0UL3ERGZGnn6/fJhueKeJpuzdIKjHaLLcX1Oiqy9MGS74VJ9Pgvjd+N+wwPenY3gMxOcZpEBStCOgYWfKofyInR1bN3aMlTgcBxm+FR4IuVXNOajOGjOt6mQWu3V1J56oC61KVZJO+4kxDgolc85XwDduwPtstUgBc1FAYF4CwECgYEAi9/5+Y+fV6Vhg7s069mGwhW28QERNQEvZAK6C3MjHNhI/Q8sYlujyaq+wDS59IUVytIglGfODLUOQjzy1B8APqw5JJgM9gErNQJDy2YJ+DKkEfG5BoghfJYTj2f7JvQqmGRst7Uq84Nc6B+0O2kfW89P83ppxsqHqbLVqkMdvgkCgYBfZNXUzEvGkLgnNF3z+MXw438CjdBsbO6rObJfqipsTe5G5caPvoJFMtlh4Sh++8fsaFp8EzkBt5d8coaFghsWidYp+gPu1NWSKr/fhhXx+HwRb6n1KlOzGdNW2W4+TJAErsPcE/WNeYIvh50c2O+CH//PwAz8+8KjFqZDRWXJyA==" ],
        "keyUse" : [ "SIG" ],
        "certificate" : [ "MIICnTCCAYUCBgGIU4S62TANBgkqhkiG9w0BAQsFADASMRAwDgYDVQQDDAdlbnRhbmRvMB4XDTIzMDUyNTE1MjQ0N1oXDTMzMDUyNTE1MjYyN1owEjEQMA4GA1UEAwwHZW50YW5kbzCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAJpiEf/Uk5YjK/h8pfPoYKBpcbjnzuEb0v3oebpKRquCIXfF/i8Vld2xRYQmQmTTtKiNlQXZV9k7rIT7ohPplhF4PJFqkxf3/mz1WANKFQgJqZgfN6UABze5hxMEH6gMpWWjNg/2UlH0Xraq0yX1iOsPcZUYjFdlpXqq+I7uk+BH4uaa3l0naglX64hqlX64rFxdOXBaVsMMeBW0M+inFpbP1bE7XJI8/0XI8S574tkORuC8f2cl7BjLmY7AuQ2+rihoK43VnLUx++2VIaa6KWtraOWx1VtFh0q1FOa/yYSiGOefYEsH03HkCG0j37dGwU/9dkDJibR/ifRPv7uK5YkCAwEAATANBgkqhkiG9w0BAQsFAAOCAQEACx87tOP1UI+DfF2gi7X1VX6+kfG8k/5WO5nv6v04R/ic5MLRSbfJ7/bn8YMA4ISGVHmMsmE0ny0kb47vfxg/oElZf4OZUsBnZaFKRj86/aZ3y/e792M0Cav7EORf3oq5dV2cJvTuSSRRZmcvK/SnFGEP8Uuh7qQMuD2mxfS6OdssIsVs7cbfKWPg1LCzQ2piHvikmiYv2fOaTffY4w4AO/4+rMJRoDp8pQKOtBhj5akfpXSFwzJDOa9bBAsla7iDHLlU18wF6okboTB6qI0weS9lQHDLE8sg/zmEY8DmKLtAfMiIPMZxlTQJ+nUvIg4AftrQxxRlWu/XrhlvtlQsWQ==" ],
        "priority" : [ "100" ]
      }
    } ]
  },
  "internationalizationEnabled" : false,
  "supportedLocales" : [ ],
  "authenticationFlows" : [ {
    "alias" : "Account verification options",
    "description" : "Method with which to verity the existing account",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "idp-email-verification",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "ALTERNATIVE",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "Verify Existing Account by Re-authentication",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "Authentication Options",
    "description" : "Authentication options.",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "basic-auth",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "basic-auth-otp",
      "authenticatorFlow" : false,
      "requirement" : "DISABLED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "auth-spnego",
      "authenticatorFlow" : false,
      "requirement" : "DISABLED",
      "priority" : 30,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "Browser - Conditional OTP",
    "description" : "Flow to determine if the OTP is required for the authentication",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "conditional-user-configured",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "auth-otp-form",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "Direct Grant - Conditional OTP",
    "description" : "Flow to determine if the OTP is required for the authentication",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "conditional-user-configured",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "direct-grant-validate-otp",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "First broker login - Conditional OTP",
    "description" : "Flow to determine if the OTP is required for the authentication",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "conditional-user-configured",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "auth-otp-form",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "Handle Existing Account",
    "description" : "Handle what to do if there is existing account with same email/username like authenticated identity provider",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "idp-confirm-link",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "Account verification options",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "Reset - Conditional OTP",
    "description" : "Flow to determine if the OTP should be reset or not. Set to REQUIRED to force.",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "conditional-user-configured",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "reset-otp",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "User creation or linking",
    "description" : "Flow for the existing/non-existing user alternatives",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticatorConfig" : "create unique user config",
      "authenticator" : "idp-create-user-if-unique",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "ALTERNATIVE",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "Handle Existing Account",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "Verify Existing Account by Re-authentication",
    "description" : "Reauthentication of existing account",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "idp-username-password-form",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "CONDITIONAL",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "First broker login - Conditional OTP",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "browser",
    "description" : "browser based authentication",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "auth-cookie",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "auth-spnego",
      "authenticatorFlow" : false,
      "requirement" : "DISABLED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "identity-provider-redirector",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 25,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "ALTERNATIVE",
      "priority" : 30,
      "autheticatorFlow" : true,
      "flowAlias" : "forms",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "clients",
    "description" : "Base authentication for clients",
    "providerId" : "client-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "client-secret",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "client-jwt",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "client-secret-jwt",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 30,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "client-x509",
      "authenticatorFlow" : false,
      "requirement" : "ALTERNATIVE",
      "priority" : 40,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "direct grant",
    "description" : "OpenID Connect Resource Owner Grant",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "direct-grant-validate-username",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "direct-grant-validate-password",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "CONDITIONAL",
      "priority" : 30,
      "autheticatorFlow" : true,
      "flowAlias" : "Direct Grant - Conditional OTP",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "docker auth",
    "description" : "Used by Docker clients to authenticate against the IDP",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "docker-http-basic-authenticator",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "first broker login",
    "description" : "Actions taken after first broker login with identity provider account, which is not yet linked to any Keycloak account",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticatorConfig" : "review profile config",
      "authenticator" : "idp-review-profile",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "User creation or linking",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "forms",
    "description" : "Username, password, otp and other auth forms.",
    "providerId" : "basic-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "auth-username-password-form",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "CONDITIONAL",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "Browser - Conditional OTP",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "http challenge",
    "description" : "An authentication flow based on challenge-response HTTP Authentication Schemes",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "no-cookie-redirect",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : true,
      "flowAlias" : "Authentication Options",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "registration",
    "description" : "registration flow",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "registration-page-form",
      "authenticatorFlow" : true,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : true,
      "flowAlias" : "registration form",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "registration form",
    "description" : "registration form",
    "providerId" : "form-flow",
    "topLevel" : false,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "registration-user-creation",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "registration-profile-action",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 40,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "registration-password-action",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 50,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "registration-recaptcha-action",
      "authenticatorFlow" : false,
      "requirement" : "DISABLED",
      "priority" : 60,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "reset credentials",
    "description" : "Reset credentials for a user if they forgot their password or something",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "reset-credentials-choose-user",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "reset-credential-email",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 20,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticator" : "reset-password",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 30,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    }, {
      "authenticatorFlow" : true,
      "requirement" : "CONDITIONAL",
      "priority" : 40,
      "autheticatorFlow" : true,
      "flowAlias" : "Reset - Conditional OTP",
      "userSetupAllowed" : false
    } ]
  }, {
    "alias" : "saml ecp",
    "description" : "SAML ECP Profile Authentication Flow",
    "providerId" : "basic-flow",
    "topLevel" : true,
    "builtIn" : true,
    "authenticationExecutions" : [ {
      "authenticator" : "http-basic-authenticator",
      "authenticatorFlow" : false,
      "requirement" : "REQUIRED",
      "priority" : 10,
      "autheticatorFlow" : false,
      "userSetupAllowed" : false
    } ]
  } ],
  "authenticatorConfig" : [ {
    "alias" : "create unique user config",
    "config" : {
      "require.password.update.after.registration" : "false"
    }
  }, {
    "alias" : "review profile config",
    "config" : {
      "update.profile.on.first.login" : "missing"
    }
  } ],
  "requiredActions" : [ {
    "alias" : "CONFIGURE_TOTP",
    "name" : "Configure OTP",
    "providerId" : "CONFIGURE_TOTP",
    "enabled" : true,
    "defaultAction" : false,
    "priority" : 10,
    "config" : { }
  }, {
    "alias" : "terms_and_conditions",
    "name" : "Terms and Conditions",
    "providerId" : "terms_and_conditions",
    "enabled" : false,
    "defaultAction" : false,
    "priority" : 20,
    "config" : { }
  }, {
    "alias" : "UPDATE_PASSWORD",
    "name" : "Update Password",
    "providerId" : "UPDATE_PASSWORD",
    "enabled" : true,
    "defaultAction" : false,
    "priority" : 30,
    "config" : { }
  }, {
    "alias" : "UPDATE_PROFILE",
    "name" : "Update Profile",
    "providerId" : "UPDATE_PROFILE",
    "enabled" : true,
    "defaultAction" : false,
    "priority" : 40,
    "config" : { }
  }, {
    "alias" : "VERIFY_EMAIL",
    "name" : "Verify Email",
    "providerId" : "VERIFY_EMAIL",
    "enabled" : true,
    "defaultAction" : false,
    "priority" : 50,
    "config" : { }
  }, {
    "alias" : "delete_account",
    "name" : "Delete Account",
    "providerId" : "delete_account",
    "enabled" : false,
    "defaultAction" : false,
    "priority" : 60,
    "config" : { }
  }, {
    "alias" : "update_user_locale",
    "name" : "Update User Locale",
    "providerId" : "update_user_locale",
    "enabled" : true,
    "defaultAction" : false,
    "priority" : 1000,
    "config" : { }
  } ],
  "browserFlow" : "browser",
  "registrationFlow" : "registration",
  "directGrantFlow" : "direct grant",
  "resetCredentialsFlow" : "reset credentials",
  "clientAuthenticationFlow" : "clients",
  "dockerAuthenticationFlow" : "docker auth",
  "attributes" : {
    "cibaBackchannelTokenDeliveryMode" : "poll",
    "cibaExpiresIn" : "120",
    "cibaAuthRequestedUserHint" : "login_hint",
    "oauth2DeviceCodeLifespan" : "600",
    "oauth2DevicePollingInterval" : "5",
    "parRequestUriLifespan" : "60",
    "cibaInterval" : "5"
  },
  "keycloakVersion" : "18.0.2",
  "userManagedAccessAllowed" : false,
  "clientProfiles" : {
    "profiles" : [ ]
  },
  "clientPolicies" : {
    "policies" : [ ]
  }
}
EOF
}

newRealm() {
  # Get the access_token from keycloak and create the realm
  access_token=$(curl -d "client_id=$KC_ADMIN_CLI" -d "username=$KC_ADMIN" -d "password=$KC_PASSWORD_ADMIN" -d "grant_type=$KC_GRANT_TYPE" "$KC_PROTOCOL://$KC_AUTH_URL/auth/realms/master/protocol/openid-connect/token" | sed -n 's|.*"access_token":"\([^"]*\)".*|\1|p')
  echo "Access Token: $access_token"

  if [ "$access_token" = "" ]; then
    echo >&2 "Error: unable to get the access token from keyclok: ($access_token)"
    exit 1
  fi

  new_realm=$(curl -d @"./$TENANT-keycloak-realm.json" -H "Content-Type: application/json" -H "Authorization: bearer $access_token" "$KC_PROTOCOL://$KC_AUTH_URL/auth/admin/realms")
  if [ "$new_realm" = "" ]; then
    echo "The realm '$TENANT' has been created."
  else
    echo >&2 "Error: unable to create the realm '$TENANT'. $new_realm"
    exit 1
  fi

  # Now that we have the new realm for the tenant we can proceed and get the public certificate from the new realm
  # `KC_PUB_CERT` is the public certificate of the new realm
  KC_PUB_CERT=$(curl "$KC_PROTOCOL://$KC_AUTH_URL/auth/realms/$TENANT" | jq '.public_key' | tr -d \")

  # Check if this is the first tenant or not.
  if [ -f ./"$NAMESPACE".check ]; then
    # Scale down the entando-de-app to make it reload the secret
    kubectl scale deploy "$APP_NAME"-deployment --replicas=0
    kubectl scale deploy "$APP_NAME"-cm-deployment --replicas=0
    sleep 30

    # we need also to patch the bundle configuration secret to add the new tenant
    cat >bundle-tenant-"$TENANT".json <<EOF
{
  "environment_variables": [
   {
    "name": "ENTANDO_TENANT_CODE",
    "value": "$TENANT"
   }
 ]
}
EOF
    secret_value=$(cat bundle-tenant-"$TENANT".json | base64 -w 0)
    kubectl patch secret "$BUNDLE_SECRET_CONF"-conf --type=json -p='[{"op": "add", "path": "/data/'"$TENANT"'", "value": "'"$secret_value"'"}]'
    # The file already exists, so we need to cat it and add the new tenant configuration to it
    cat >tenant-json-"$TENANT".json <<EOF
       ,{
            "tenantCode": "$TENANT",
            "entandoAppIngressName": "$TENANT-$APP_NAME-ingress",
            "fqdns": "$TENANT.$KC_AUTH_URL",
            "kcEnabled": true,
            "kcAuthUrl": "$KC_PROTOCOL://$KC_AUTH_URL/auth",
            "kcInternalAuthUrl": "$KC_INTERNAL_URI",
            "kcAdminUsername": "$KC_ADMIN",
            "kcAdminPassword": "$KC_PASSWORD_ADMIN",
            "kcRealm": "$TENANT",
            "kcClientId": "$KC_CLIENT_ID",
            "kcClientSecret": "$KC_APP_NAME_CLIENT_ID_SECRET",
            "kcPublicClientId": "entando-web",
            "kcSecureUris": "",
            "kcDefaultAuthorizations": "",
            "dbDriverClassName": "org.postgresql.Driver",
            "dbUrl": "jdbc:postgresql://default-postgresql-dbms-in-namespace-service.$NAMESPACE.svc.cluster.local:5432/default_postgresql_dbms_in_namespace_db?currentSchema=$TENANT",
            "dbUsername": "postgres",
            "dbPassword": "$DB_PASSWORD",
            "cdsPublicUrl": "$KC_PROTOCOL://$TENANT-cds.$KC_AUTH_URL/$TENANT",
            "cdsPrivateUrl": "http://$TENANT-cds-service:8080",
            "cdsPath": "api/v1",
            "solrAddress": "http://solr-solrcloud-common/solr",
            "solrCore": "$TENANT",
            "deDbDriverClassName": "org.postgresql.Driver",
            "deDbUrl": "jdbc:postgresql://default-postgresql-dbms-in-namespace-service.$NAMESPACE.svc.cluster.local:5432/default_postgresql_dbms_in_namespace_db?currentSchema=$TENANT$DE_DB_SUFFIX",
            "deDbUsername": "postgres",
            "deDbPassword": "$DB_PASSWORD",
            "deKcClientId": "$APP_NAME-de",
            "deKcClientSecret": "$KC_CM_CLIENT_ID_SECRET"
        }
EOF
  else
    # The file does not exists so we need to create it
    touch ./"$NAMESPACE".check
    echo "1" >>./"$NAMESPACE".check
    # Scale down the entando-de-app and the component-manager to add the env variables for the cds
    kubectl scale deploy "$APP_NAME"-deployment --replicas=0
    kubectl scale deploy "$APP_NAME"-cm-deployment --replicas=0
    sleep 30

  # we need also to patch the bundle configuration secret to add the new tenant
    cat >bundle-tenant-"$TENANT".json <<EOF
{
  "environment_variables": [
   {
    "name": "ENTANDO_TENANT_CODE",
    "value": "$TENANT"
   }
 ]
}
EOF
    secret_value=$(cat bundle-tenant-"$TENANT".json | base64 -w 0)
    kubectl patch secret "$BUNDLE_SECRET_CONF"-conf --type=json -p='[{"op": "add", "path": "/data/'"$TENANT"'", "value": "'"$secret_value"'"}]'

    # Now we need to generate the tenant-$TENANT.json file
    cat >tenant-json-0-"$TENANT".json <<EOF
        {
            "tenantCode": "$TENANT",
            "entandoAppIngressName": "$TENANT-$APP_NAME-ingress",
            "fqdns": "$TENANT.$KC_AUTH_URL",
            "kcEnabled": true,
            "kcAuthUrl": "$KC_PROTOCOL://$KC_AUTH_URL/auth",
            "kcInternalAuthUrl": "$KC_INTERNAL_URI",
            "kcAdminUsername": "$KC_ADMIN",
            "kcAdminPassword": "$KC_PASSWORD_ADMIN",
            "kcRealm": "$TENANT",
            "kcClientId": "$KC_CLIENT_ID",
            "kcClientSecret": "$KC_APP_NAME_CLIENT_ID_SECRET",
            "kcPublicClientId": "entando-web",
            "kcSecureUris": "",
            "kcDefaultAuthorizations": "",
            "dbDriverClassName": "org.postgresql.Driver",
            "dbUrl": "jdbc:postgresql://default-postgresql-dbms-in-namespace-service.$NAMESPACE.svc.cluster.local:5432/default_postgresql_dbms_in_namespace_db?currentSchema=$TENANT",
            "dbUsername": "postgres",
            "dbPassword": "$DB_PASSWORD",
            "cdsPublicUrl": "$KC_PROTOCOL://$TENANT-cds.$KC_AUTH_URL/$TENANT",
            "cdsPrivateUrl": "http://$TENANT-cds-service:8080",
            "cdsPath": "api/v1",
            "solrAddress": "http://solr-solrcloud-common/solr",
            "solrCore": "$TENANT",
            "deDbDriverClassName": "org.postgresql.Driver",
            "deDbUrl": "jdbc:postgresql://default-postgresql-dbms-in-namespace-service.$NAMESPACE.svc.cluster.local:5432/default_postgresql_dbms_in_namespace_db?currentSchema=$TENANT$DE_DB_SUFFIX",
            "deDbUsername": "postgres",
            "deDbPassword": "$DB_PASSWORD",
            "deKcClientId": "$APP_NAME-de",
            "deKcClientSecret": "$KC_CM_CLIENT_ID_SECRET"
        }
EOF
  fi

  FINAL_JSON=$(cat tenant-json-*)
  cat >entando-tenants-secret.json <<EOF
 [
    $FINAL_JSON
 ]
EOF

  # Create the entando-tenants-secret
  # Check if the secret `entando-tenants-secret` already exists and if it exists, delete it.
  kubectl get secret "$ENTANDO_TENANT_SECRET"
  if [ $? -eq 0 ]; then
    kubectl delete secret "$ENTANDO_TENANT_SECRET"
    # we need to delete also the `TENANT-CONFIG-SECRET`
    #kubectl delete secret "$TENANT_CONFIG_SECRET"
    # We need to recreate the secret with the new values
    kubectl create secret generic "$ENTANDO_TENANT_SECRET" --from-literal "ENTANDO_TENANTS=$(cat entando-tenants-secret.json)"
    #kubectl create secret generic "$TENANT_CONFIG_SECRET" --from-literal "ENTANDO_TENANTS=$(cat entando-tenants-secret.json)"
  else
    kubectl create secret generic "$ENTANDO_TENANT_SECRET" --from-literal "ENTANDO_TENANTS=$(cat entando-tenants-secret.json)"
    #kubectl create secret generic "$TENANT_CONFIG_SECRET" --from-literal "ENTANDO_TENANTS=$(cat entando-tenants-secret.json)"
  fi

  # Add `ENTANDO_TENANTS` env var to the de-app
  kubectl set env --from=secret/"$ENTANDO_TENANT_SECRET" deployment/"$APP_NAME"-deployment
  # Add `TENANT-CONFIGS` env var to the CM
  kubectl set env --from=secret/"$ENTANDO_TENANT_SECRET" deployment/"$APP_NAME"-cm-deployment
  # Add the  `Tenant` core
  curl "http://$NAMESPACE-solr-solrcloud.$KC_AUTH_URL/solr/admin/collections?action=CREATE&name=$TENANT&numShards=1&replicationFactor=3&maxShardsPerNode=2"

}

genNewSchema() {
  # Export the portdb and servdb schemas
  kubectl exec -it "$DB_POD" -- pg_dump -O -n "$PORTDB_SCHEMA" -n "$SERVDB_SCHEMA" "$DEFAULT_ENTANDO_DB" >db_export.sql
  if [ $? -eq 0 ]; then
    echo "$PORTDB_SCHEMA and $SERVDB_SCHEMA have been exported to db_export.sql"
    echo
  fi
  # Replace the schema name in the export file
  echo "Dumping..."
  echo
  sed -i "s/$PORTDB_SCHEMA/$TENANT/g; s/$SERVDB_SCHEMA/$TENANT/g" db_export.sql
  echo "Dump file has been updated with your $TENANT references"
  echo
  # Create the new tenant schema and populate it with data
  kubectl exec -it "$DB_POD" -- psql -d "$DEFAULT_ENTANDO_DB" <db_export.sql
  echo "The new < $TENANT > schema has been created with all the data"
  echo
  # Truncate the Liquibase table to skip the error related to the missing schemas
  kubectl exec -it "$DB_POD" -- psql -d "$DEFAULT_ENTANDO_DB" -c "TRUNCATE $TENANT.databasechangeloglock;"
  echo "The liquibase table has been truncated correctly"
  echo
}

genNewCMSchema() {
  echo "$DE_DB_SCHEMA"
  # Export the dedb schema with no data
  kubectl exec -it "$DB_POD" -- pg_dump -O -n "$DE_DB_SCHEMA" --schema-only "$DEFAULT_ENTANDO_DB" >dedb_export.sql
  if [ $? -eq 0 ]; then
    echo "$DE_DB_SCHEMA has been exported to dedb_export.sql"
    echo ""
  fi
  # replace the schema name in the export file
  echo "Dumping"
  echo ""
  sed -i "s/$DE_DB_SCHEMA/$TENANT$DE_DB_SUFFIX/g" dedb_export.sql
  echo "Dump file has been updated with your $TENANT$DE_DB_SUFFIX reference"
  echo ""
  # Create the new dedb schema for the tenant
  kubectl exec -it "$DB_POD" -- psql -d "$DEFAULT_ENTANDO_DB" <dedb_export.sql
  echo "The new < $TENANT$DE_DB_SUFFIX > schema has been created"
  echo
}

genIngressTenant() {
  # Generate the ingress for the tenant
  if [ "$KC_PROTOCOL" = "http" ]; then
    cat >ingress-"$TENANT"-"$APP_NAME".yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/affinity-mode: persistent
    nginx.ingress.kubernetes.io/session-cookie-name: ROUTE
    entando.org/$APP_NAME-appbuilder-path: /app-builder/
    entando.org/$APP_NAME-de-path: /digital-exchange
    entando.org/$APP_NAME-server-path: /entando-de-app
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.org/client-max-body-size: "50m"
    nginx.ingress.kubernetes.io/proxy-buffer-size: 64k
  generation: 4
  labels:
    EntandoApp: $APP_NAME
    EntandoTenant: $TENANT
  name: $TENANT-$APP_NAME-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: $TENANT.$KC_AUTH_URL
    http:
      paths:
      - backend:
          service:
            name: $APP_NAME-ab-service
            port:
              number: 8081
        path: /app-builder/
        pathType: Prefix
      - backend:
          service:
            name: $APP_NAME-service
            port:
              number: 8080
        path: /entando-de-app
        pathType: Prefix
      - backend:
          service:
            name: $APP_NAME-cm-service
            port:
              number: 8083
        path: /digital-exchange
        pathType: Prefix
      - backend:
          service:
            name: pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-service
            port:
              number: 8081
        path: /entando-epc-bootstrap-3c07adf0/app-builder-menu-bff
        pathType: Prefix
EOF
  else
    cat >ingress-"$TENANT"-"$APP_NAME".yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/affinity: cookie
    nginx.ingress.kubernetes.io/affinity-mode: persistent
    nginx.ingress.kubernetes.io/session-cookie-name: ROUTE
    nginx.ingress.kubernetes.io/session-cookie-secure: "true"
    nginx.ingress.kubernetes.io/proxy-body-size: "50m"
    nginx.org/client-max-body-size: "50m"
    nginx.ingress.kubernetes.io/proxy-buffer-size: 64k
    cert-manager.io/cluster-issuer: letsencrypt-prod-cluster
    entando.org/$APP_NAME-appbuilder-path: /app-builder/
    entando.org/$APP_NAME-de-path: /digital-exchange
    entando.org/$APP_NAME-server-path: /entando-de-app
  generation: 4
  labels:
    EntandoApp: $APP_NAME
  name: $TENANT-$APP_NAME-ingress
spec:
  ingressClassName: nginx
  rules:
  - host: $TENANT.$KC_AUTH_URL
    http:
      paths:
      - backend:
          service:
            name: $APP_NAME-ab-service
            port:
              number: 8081
        path: /app-builder/
        pathType: Prefix
      - backend:
          service:
            name: $APP_NAME-service
            port:
              number: 8080
        path: /entando-de-app
        pathType: Prefix
      - backend:
          service:
            name: $APP_NAME-cm-service
            port:
              number: 8083
        path: /digital-exchange
        pathType: Prefix
      - backend:
          service:
            name: pn-3c07adf0-fac54a9f-entando-app-builder-menu-bff-service
            port:
              number: 8081
        path: /entando-epc-bootstrap-3c07adf0/app-builder-menu-bff
        pathType: Prefix
  tls:
    - hosts:
        - $TENANT.$KC_AUTH_URL
      secretName: $TENANT-tls-secret
EOF

  fi
  # Apply the ingress
  kubectl apply -f ingress-"$TENANT"-"$APP_NAME".yaml
}

genPrimaryCDS() {
  # Create the control file for the installation of the primary CDS, this way the primary CDS will be installed only once
  touch "$APP_NAME"-cds.check
  # Scale down the de-app instance to add the needed env vars
  kubectl scale deploy "$APP_NAME"-deployment --replicas=0
  sleep 30
  # Add the ENV VARS for the CDS
  kubectl set env deployment/"$APP_NAME"-deployment CDS_ENABLED="true"
  kubectl set env deployment/"$APP_NAME"-deployment CDS_PUBLIC_URL="$KC_PROTOCOL://$TENANT-cds.$KC_AUTH_URL/$TENANT"
  kubectl set env deployment/"$APP_NAME"-deployment CDS_PRIVATE_URL="http://$TENANT-cds-service:8080"
  kubectl set env deployment/"$APP_NAME"-deployment CDS_PATH=/api/v1
  # Add ENV VARS for Redis
  kubectl set env deployment/"$APP_NAME"-deployment REDIS_ACTIVE="true"
  kubectl set env deployment/"$APP_NAME"-deployment REDIS_ADDRESSES="redis-node-0.redis-headless.$NAMESPACE.svc.cluster.local:26379,redis-node-1.redis-headless.$NAMESPACE.svc.cluster.local:26379,redis-node-2.redis-headless.$NAMESPACE.svc.cluster.local:26379"
  kubectl set env deployment/"$APP_NAME"-deployment REDIS_SESSION_ACTIVE="true"
  kubectl set env deployment/"$APP_NAME"-deployment REDIS_USE_SENTINEL_EVENTS="true"

  # Remove the volumeMount
  kubectl patch deploy "$APP_NAME"-deployment --type json -p='[{"op": "remove", "path": "/spec/template/spec/containers/0/volumeMounts/0"}]'
  # Remove the volume
  kubectl patch deploy "$APP_NAME"-deployment --type json -p='[{"op": "remove", "path": "/spec/template/spec/volumes/0"}]'
  # Remove the pvc
  kubectl delete pvc "$APP_NAME"-server-pvc
  # Add the bundle secret
   # we need also to add the new tenant configuration secret for the bundle
    cat >bundle-tenant-"$TENANT".json <<EOF
{
  "environment_variables": [
   {
    "name": "ENTANDO_TENANT_CODE",
    "value": "$TENANT"
   }
 ]
}
EOF
  # We create the bundle secret configuration to be consumed by entando-k8s-service
  kubectl create secret generic "$BUNDLE_SECRET_CONF"-conf --from-literal "$TENANT=$(cat bundle-tenant-$TENANT.json)"

  # Install the CDS service for the tenant
  cat >"$TENANT"-cds-deployment.yaml <<EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    deployment: $TENANT-cds-deploy
  name: $TENANT-cds-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    limits:
      storage: 50Gi
    requests:
      storage: 50Gi
  #storageClassName: standard
---
apiVersion: v1
kind: Secret
metadata:
  name: $TENANT-kc-pk-secret
type: Opaque
stringData:
  KC_PUBLIC_KEY: "-----BEGIN PUBLIC KEY-----\n$KC_PUB_CERT_ENTANDO\n-----END PUBLIC KEY-----\n"
---
apiVersion: v1
kind: Service
metadata:
  name: $TENANT-cds-service
  labels:
    app: $TENANT-cds
spec:
  ports:
    - port: 8080
      name: internal-port
      protocol: TCP
      targetPort: 8080
    - port: 8081
      name: public-port
      protocol: TCP
      targetPort: 8081
  selector:
    app: $TENANT-cds
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: $TENANT-cds-deploy
  labels:
    app: $TENANT-cds
spec:
  selector:
    matchLabels:
      app: $TENANT-cds
  template:
    metadata:
      labels:
        app: $TENANT-cds
    spec:
      initContainers:
        - name: init-cds-data
          env:
            - name: FORCE_CDS
              value: "false"
            - name: REPO_PATH
              value: https://raw.github.com/entando-ps/cds/entando730/entando-data/
            - name: ARCHIVE_NAME
              value: entando730.tar.gz
          image: registry.hub.docker.com/entando/busybox-cds:1.36.0
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - mountPath: /entando-data
              name: $TENANT-cds-data-volume
      containers:
        - readinessProbe:
            httpGet:
              port: 8081
              path: /health/health_check
              scheme: HTTP
            failureThreshold: 1
            initialDelaySeconds: 5
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 5
          env:
            - name: RUST_LOG
              value: actix_web=info,actix_server=info,actix_web_middleware_keycloak_auth=info
            - name: KEYCLOAK_PUBLIC_KEY
              valueFrom:
                secretKeyRef:
                  key: KC_PUBLIC_KEY
                  name: $TENANT-kc-pk-secret
            - name: CORS_ALLOWED_ORIGIN
              value: All
            - name: CORS_ALLOWED_ORIGIN_END_WITH
              value: $KC_AUTH_URL
          name: $TENANT-cds
          image: docker.io/entando/cds:1.0.4
          imagePullPolicy: IfNotPresent
          livenessProbe:
            httpGet:
              scheme: HTTP
              port: 8081
              path: /health/health_check
            timeoutSeconds: 5
            successThreshold: 1
            periodSeconds: 30
            initialDelaySeconds: 5
            failureThreshold: 1
          ports:
            - containerPort: 8080
              name: internal-port
            - containerPort: 8081
              name: public-port
          resources:
            limits:
              cpu: 1000m
              memory: 500Mi
            requests:
              cpu: 500m
              memory: 500Mi
          volumeMounts:
            - mountPath: /entando-data
              name: $TENANT-cds-data-volume
      volumes:
        - name: $TENANT-cds-data-volume
          persistentVolumeClaim:
            claimName: $TENANT-cds-pvc
            readOnly: false
  replicas: 1
EOF

  # Check the protocol to install the correct ingress configuration on PS-DEV
  if [ "$KC_PROTOCOL" = "http" ]; then

    cat >"$TENANT"-cds-ingress.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: $TENANT-cds-ingress
  annotations:

spec:
  ingressClassName: nginx
  rules:
    - host: $TENANT-cds.$KC_AUTH_URL
      http:
        paths:
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8081
            pathType: ImplementationSpecific
            path: /
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8080
            pathType: ImplementationSpecific
            path: /api/v1/
EOF
  else
    cat >"$TENANT"-cds-ingress.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: $TENANT-cds-ingress
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod-cluster
spec:
  ingressClassName: nginx
  rules:
    - host: $TENANT-cds.$KC_AUTH_URL
      http:
        paths:
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8081
            pathType: ImplementationSpecific
            path: /
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8080
            pathType: ImplementationSpecific
            path: /api/v1/
  tls:
    - hosts:
        - $TENANT-cds.$KC_AUTH_URL
      secretName: $TENANT-cds-tls-secret
EOF
  fi
}

genSecondaryCDS() {
  # Install the CDS service for the tenant
  cat >"$TENANT"-cds-deployment.yaml <<EOF
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  labels:
    deployment: $TENANT-cds-deploy
  name: $TENANT-cds-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    limits:
      storage: 50Gi
    requests:
      storage: 50Gi
  #storageClassName: standard
---
apiVersion: v1
kind: Secret
metadata:
  name: $TENANT-kc-pk-secret
type: Opaque
stringData:
  KC_PUBLIC_KEY: "-----BEGIN PUBLIC KEY-----\n$KC_PUB_CERT\n-----END PUBLIC KEY-----\n"
---
apiVersion: v1
kind: Service
metadata:
  name: $TENANT-cds-service
  labels:
    app: $TENANT-cds
spec:
  ports:
    - port: 8080
      name: internal-port
      protocol: TCP
      targetPort: 8080
    - port: 8081
      name: public-port
      protocol: TCP
      targetPort: 8081
  selector:
    app: $TENANT-cds
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: $TENANT-cds-deploy
  labels:
    app: $TENANT-cds
spec:
  selector:
    matchLabels:
      app: $TENANT-cds
  template:
    metadata:
      labels:
        app: $TENANT-cds
    spec:
      initContainers:
        - name: init-cds-data
          env:
            - name: FORCE_CDS
              value: "false"
            - name: REPO_PATH
              value: https://raw.github.com/entando-ps/cds/entando730/entando-data/
            - name: ARCHIVE_NAME
              value: entando730.tar.gz
          image: registry.hub.docker.com/entando/busybox-cds:1.36.0
          imagePullPolicy: IfNotPresent
          volumeMounts:
            - mountPath: /entando-data
              name: $TENANT-cds-data-volume
      containers:
        - readinessProbe:
            httpGet:
              port: 8081
              path: /health/health_check
              scheme: HTTP
            failureThreshold: 1
            initialDelaySeconds: 5
            periodSeconds: 5
            successThreshold: 1
            timeoutSeconds: 5
          env:
            - name: RUST_LOG
              value: actix_web=info,actix_server=info,actix_web_middleware_keycloak_auth=info
            - name: KEYCLOAK_PUBLIC_KEY
              valueFrom:
                secretKeyRef:
                  key: KC_PUBLIC_KEY
                  name: $TENANT-kc-pk-secret
            - name: CORS_ALLOWED_ORIGIN
              value: All
            - name: CORS_ALLOWED_ORIGIN_END_WITH
              value: $KC_AUTH_URL
          name: $TENANT-cds
          image: docker.io/entando/cds:1.0.4
          imagePullPolicy: IfNotPresent
          livenessProbe:
            httpGet:
              scheme: HTTP
              port: 8081
              path: /health/health_check
            timeoutSeconds: 5
            successThreshold: 1
            periodSeconds: 30
            initialDelaySeconds: 5
            failureThreshold: 1
          ports:
            - containerPort: 8080
              name: internal-port
            - containerPort: 8081
              name: public-port
          resources:
            limits:
              cpu: 1000m
              memory: 500Mi
            requests:
              cpu: 500m
              memory: 500Mi
          volumeMounts:
            - mountPath: /entando-data
              name: $TENANT-cds-data-volume
      volumes:
        - name: $TENANT-cds-data-volume
          persistentVolumeClaim:
            claimName: $TENANT-cds-pvc
            readOnly: false
  replicas: 1
EOF

  # Check the protocol to install the correct ingress configuration on PS-DEV
  if [ "$KC_PROTOCOL" = "http" ]; then

    cat >"$TENANT"-cds-ingress.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: $TENANT-cds-ingress
  annotations:
spec:
  ingressClassName: nginx
  rules:
    - host: $TENANT-cds.$KC_AUTH_URL
      http:
        paths:
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8081
            pathType: ImplementationSpecific
            path: /
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8080
            pathType: ImplementationSpecific
            path: /api/v1/
EOF
  else
    cat >"$TENANT"-cds-ingress.yaml <<EOF
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: $TENANT-cds-ingress
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod-cluster
spec:
  ingressClassName: nginx
  rules:
    - host: $TENANT-cds.$KC_AUTH_URL
      http:
        paths:
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8081
            pathType: ImplementationSpecific
            path: /
          - backend:
              service:
                name: $TENANT-cds-service
                port:
                  number: 8080
            pathType: ImplementationSpecific
            path: /api/v1/
  tls:
    - hosts:
        - $TENANT-cds.$KC_AUTH_URL
      secretName: $TENANT-cds-tls-secret
EOF
  fi
}

installRedis() {
  # create the redis values.yaml configuration file
  cat >redis-values.yaml <<EOF
## @section Global parameters
## Global Docker image parameters
## Please, note that this will override the image parameters, including dependencies, configured to use the global value
## Current available global Docker image parameters: imageRegistry, imagePullSecrets and storageClass
##

## @param global.imageRegistry Global Docker image registry
## @param global.imagePullSecrets Global Docker registry secret names as an array
## @param global.storageClass Global StorageClass for Persistent Volume(s)
## @param global.redis.password Global Redis&reg; password (overrides $(auth.password))
##
global:
  imageRegistry: ""
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []
  storageClass: ""
  redis:
    password: ""

## @section Common parameters
##

## @param kubeVersion Override Kubernetes version
##
kubeVersion: ""
## @param nameOverride String to partially override common.names.fullname
##
nameOverride: ""
## @param fullnameOverride String to fully override common.names.fullname
##
fullnameOverride: ""
## @param commonLabels Labels to add to all deployed objects
##
commonLabels: {}
## @param commonAnnotations Annotations to add to all deployed objects
##
commonAnnotations: {}
## @param secretAnnotations Annotations to add to secret
##
secretAnnotations: {}
## @param clusterDomain Kubernetes cluster domain name
##
clusterDomain: cluster.local
## @param extraDeploy Array of extra objects to deploy with the release
##
extraDeploy: []
## @param useHostnames Use hostnames internally when announcing replication
###
useHostnames: true

## Enable diagnostic mode in the deployment
##
diagnosticMode:
  ## @param diagnosticMode.enabled Enable diagnostic mode (all probes will be disabled and the command will be overridden)
  ##
  enabled: false
  ## @param diagnosticMode.command Command to override all containers in the deployment
  ##
  command:
    - sleep
  ## @param diagnosticMode.args Args to override all containers in the deployment
  ##
  args:
    - infinity

## @section Redis&reg; Image parameters
##

## Bitnami Redis&reg; image
## ref: https://hub.docker.com/r/bitnami/redis/tags/
## @param image.registry Redis&reg; image registry
## @param image.repository Redis&reg; image repository
## @param image.tag Redis&reg; image tag (immutable tags are recommended)
## @param image.digest Redis&reg; image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
## @param image.pullPolicy Redis&reg; image pull policy
## @param image.pullSecrets Redis&reg; image pull secrets
## @param image.debug Enable image debug mode
##
image:
  registry: docker.io
  repository: bitnami/redis
  tag: 7.0.8-debian-11-r12
  digest: ""
  ## Specify a imagePullPolicy
  ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
  ## ref: https://kubernetes.io/docs/user-guide/images/#pre-pulling-images
  ##
  pullPolicy: IfNotPresent
  ## Optionally specify an array of imagePullSecrets.
  ## Secrets must be manually created in the namespace.
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
  ## e.g:
  ## pullSecrets:
  ##   - myRegistryKeySecretName
  ##
  pullSecrets: []
  ## Enable debug mode
  ##
  debug: false

## @section Redis&reg; common configuration parameters
## https://github.com/bitnami/containers/tree/main/bitnami/redis#configuration
##

## @param architecture Redis&reg; architecture. Allowed values: \$(standalone) or \$(replication)
##
architecture: replication
## Redis&reg; Authentication parameters
## ref: https://github.com/bitnami/containers/tree/main/bitnami/redis#setting-the-server-password-on-first-run
##
auth:
  ## @param auth.enabled Enable password authentication
  ##
  enabled: false
  ## @param auth.sentinel Enable password authentication on sentinels too
  ##
  sentinel: false
  ## @param auth.password Redis&trade; password
  ## Defaults to a random 10-character alphanumeric string if not set
  ##
  password: ""
  ## @param auth.existingSecret The name of an existing secret with Redis&reg; credentials
  ## NOTE: When it's set, the previous \$(auth.password) parameter is ignored
  ##
  existingSecret: ""
  ## @param auth.existingSecretPasswordKey Password key to be retrieved from existing secret
  ## NOTE: ignored unless \$(auth.existingSecret) parameter is set
  ##
  existingSecretPasswordKey: ""
  ## @param auth.usePasswordFiles Mount credentials as files instead of using an environment variable
  ##
  usePasswordFiles: false

## @param commonConfiguration [string] Common configuration to be added into the ConfigMap
## ref: https://redis.io/topics/config
##
commonConfiguration: |-
  # Enable AOF https://redis.io/topics/persistence#append-only-file
  appendonly yes
  # Disable RDB persistence, AOF persistence already enabled.
  save ""
## @param existingConfigmap The name of an existing ConfigMap with your custom configuration for Redis&reg; nodes
##
existingConfigmap: ""

## @section Redis&reg; master configuration parameters
##

master:
  ## @param master.count Number of Redis&reg; master instances to deploy (experimental, requires additional configuration)
  ##
  count: 1
  ## @param master.configuration Configuration for Redis&reg; master nodes
  ## ref: https://redis.io/topics/config
  ##
  configuration: ""
  ## @param master.disableCommands Array with Redis&reg; commands to disable on master nodes
  ## Commands will be completely disabled by renaming each to an empty string.
  ## ref: https://redis.io/topics/security#disabling-of-specific-commands
  ##
  disableCommands:
    - FLUSHDB
    - FLUSHALL
  ## @param master.command Override default container command (useful when using custom images)
  ##
  command: []
  ## @param master.args Override default container args (useful when using custom images)
  ##
  args: []
  ## @param master.preExecCmds Additional commands to run prior to starting Redis&reg; master
  ##
  preExecCmds: []
  ## @param master.extraFlags Array with additional command line flags for Redis&reg; master
  ## e.g:
  ## extraFlags:
  ##  - "--maxmemory-policy volatile-ttl"
  ##  - "--repl-backlog-size 1024mb"
  ##
  extraFlags: []
  ## @param master.extraEnvVars Array with extra environment variables to add to Redis&reg; master nodes
  ## e.g:
  ## extraEnvVars:
  ##   - name: FOO
  ##     value: "bar"
  ##
  extraEnvVars: []
  ## @param master.extraEnvVarsCM Name of existing ConfigMap containing extra env vars for Redis&reg; master nodes
  ##
  extraEnvVarsCM: ""
  ## @param master.extraEnvVarsSecret Name of existing Secret containing extra env vars for Redis&reg; master nodes
  ##
  extraEnvVarsSecret: ""
  ## @param master.containerPorts.redis Container port to open on Redis&reg; master nodes
  ##
  containerPorts:
    redis: 6379
  ## Configure extra options for Redis&reg; containers' liveness and readiness probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
  ## @param master.startupProbe.enabled Enable startupProbe on Redis&reg; master nodes
  ## @param master.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
  ## @param master.startupProbe.periodSeconds Period seconds for startupProbe
  ## @param master.startupProbe.timeoutSeconds Timeout seconds for startupProbe
  ## @param master.startupProbe.failureThreshold Failure threshold for startupProbe
  ## @param master.startupProbe.successThreshold Success threshold for startupProbe
  ##
  startupProbe:
    enabled: false
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  ## @param master.livenessProbe.enabled Enable livenessProbe on Redis&reg; master nodes
  ## @param master.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
  ## @param master.livenessProbe.periodSeconds Period seconds for livenessProbe
  ## @param master.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
  ## @param master.livenessProbe.failureThreshold Failure threshold for livenessProbe
  ## @param master.livenessProbe.successThreshold Success threshold for livenessProbe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  ## @param master.readinessProbe.enabled Enable readinessProbe on Redis&reg; master nodes
  ## @param master.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
  ## @param master.readinessProbe.periodSeconds Period seconds for readinessProbe
  ## @param master.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
  ## @param master.readinessProbe.failureThreshold Failure threshold for readinessProbe
  ## @param master.readinessProbe.successThreshold Success threshold for readinessProbe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 5
  ## @param master.customStartupProbe Custom startupProbe that overrides the default one
  ##
  customStartupProbe: {}
  ## @param master.customLivenessProbe Custom livenessProbe that overrides the default one
  ##
  customLivenessProbe: {}
  ## @param master.customReadinessProbe Custom readinessProbe that overrides the default one
  ##
  customReadinessProbe: {}
  ## Redis&reg; master resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## @param master.resources.limits The resources limits for the Redis&reg; master containers
  ## @param master.resources.requests The requested resources for the Redis&reg; master containers
  ##
  resources:
#    limits: {}
#    requests: {}
    limits:
       cpu: 250m
       memory: 256Mi
    requests: 
       cpu: 250m
       memory: 256Mi
  ## Configure Pods Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param master.podSecurityContext.enabled Enabled Redis&reg; master pods' Security Context
  ## @param master.podSecurityContext.fsGroup Set Redis&reg; master pod's Security Context fsGroup
  ##
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  ## Configure Container Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param master.containerSecurityContext.enabled Enabled Redis&reg; master containers' Security Context
  ## @param master.containerSecurityContext.runAsUser Set Redis&reg; master containers' Security Context runAsUser
  ##
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  ## @param master.kind Use either Deployment or StatefulSet (default)
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/
  ##
  kind: StatefulSet
  ## @param master.schedulerName Alternate scheduler for Redis&reg; master pods
  ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
  ##
  schedulerName: ""
  ## @param master.updateStrategy.type Redis&reg; master statefulset strategy type
  ## @skip master.updateStrategy.rollingUpdate
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    ## StrategyType
    ## Can be set to RollingUpdate, OnDelete (statefulset), Recreate (deployment)
    ##
    type: RollingUpdate
  ## @param master.minReadySeconds How many seconds a pod needs to be ready before killing the next, during update
  ##
  minReadySeconds: 0
  ## @param master.priorityClassName Redis&reg; master pods' priorityClassName
  ##
  priorityClassName: ""
  ## @param master.hostAliases Redis&reg; master pods host aliases
  ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
  ##
  hostAliases: []
  ## @param master.podLabels Extra labels for Redis&reg; master pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## @param master.podAnnotations Annotations for Redis&reg; master pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}
  ## @param master.shareProcessNamespace Share a single process namespace between all of the containers in Redis&reg; master pods
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/
  ##
  shareProcessNamespace: false
  ## @param master.podAffinityPreset Pod affinity preset. Ignored if \$(master.affinity) is set. Allowed values: \$(soft) or \$(hard)
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ##
  podAffinityPreset: ""
  ## @param master.podAntiAffinityPreset Pod anti-affinity preset. Ignored if \$(master.affinity) is set. Allowed values: \$(soft) or \$(hard)
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ##
  podAntiAffinityPreset: soft
  ## Node master.affinity preset
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
  ##
  nodeAffinityPreset:
    ## @param master.nodeAffinityPreset.type Node affinity preset type. Ignored if \$(master.affinity) is set. Allowed values: \$(soft) or \$(hard)
    ##
    type: ""
    ## @param master.nodeAffinityPreset.key Node label key to match. Ignored if \$(master.affinity) is set
    ##
    key: ""
    ## @param master.nodeAffinityPreset.values Node label values to match. Ignored if \$(master.affinity) is set
    ## E.g.
    ## values:
    ##   - e2e-az1
    ##   - e2e-az2
    ##
    values: []
  ## @param master.affinity Affinity for Redis&reg; master pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## NOTE: \$(master.podAffinityPreset), \$(master.podAntiAffinityPreset), and \$(master.nodeAffinityPreset) will be ignored when it's set
  ##
  affinity: {}
  ## @param master.nodeSelector Node labels for Redis&reg; master pods assignment
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  ## @param master.tolerations Tolerations for Redis&reg; master pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## @param master.topologySpreadConstraints Spread Constraints for Redis&reg; master pod assignment
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  ## E.g.
  ## topologySpreadConstraints:
  ##   - maxSkew: 1
  ##     topologyKey: node
  ##     whenUnsatisfiable: DoNotSchedule
  ##
  topologySpreadConstraints: []
  ## @param master.dnsPolicy DNS Policy for Redis&reg; master pod
  ## ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
  ## E.g.
  ## dnsPolicy: ClusterFirst
  dnsPolicy: ""
  ## @param master.dnsConfig DNS Configuration for Redis&reg; master pod
  ## ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
  ## E.g.
  ## dnsConfig:
  ##   options:
  ##   - name: ndots
  ##     value: "4"
  ##   - name: single-request-reopen
  dnsConfig: {}
  ## @param master.lifecycleHooks for the Redis&reg; master container(s) to automate configuration before or after startup
  ##
  lifecycleHooks: {}
  ## @param master.extraVolumes Optionally specify extra list of additional volumes for the Redis&reg; master pod(s)
  ##
  extraVolumes: []
  ## @param master.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the Redis&reg; master container(s)
  ##
  extraVolumeMounts: []
  ## @param master.sidecars Add additional sidecar containers to the Redis&reg; master pod(s)
  ## e.g:
  ## sidecars:
  ##   - name: your-image-name
  ##     image: your-image
  ##     imagePullPolicy: Always
  ##     ports:
  ##       - name: portname
  ##         containerPort: 1234
  ##
  sidecars: []
  ## @param master.initContainers Add additional init containers to the Redis&reg; master pod(s)
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  ## e.g:
  ## initContainers:
  ##  - name: your-image-name
  ##    image: your-image
  ##    imagePullPolicy: Always
  ##    command: ['sh', '-c', 'echo "hello world"']
  ##
  initContainers: []
  ## Persistence parameters
  ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    ## @param master.persistence.enabled Enable persistence on Redis&reg; master nodes using Persistent Volume Claims
    ##
    enabled: true
    ## @param master.persistence.medium Provide a medium for \$(emptyDir) volumes.
    ##
    medium: ""
    ## @param master.persistence.sizeLimit Set this to enable a size limit for \$(emptyDir) volumes.
    ##
    sizeLimit: ""
    ## @param master.persistence.path The path the volume will be mounted at on Redis&reg; master containers
    ## NOTE: Useful when using different Redis&reg; images
    ##
    path: /data
    ## @param master.persistence.subPath The subdirectory of the volume to mount on Redis&reg; master containers
    ## NOTE: Useful in dev environments
    ##
    subPath: ""
    ## @param master.persistence.subPathExpr Used to construct the subPath subdirectory of the volume to mount on Redis&reg; master containers
    ##
    subPathExpr: ""
    ## @param master.persistence.storageClass Persistent Volume storage class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner
    ##
    storageClass: ""
    ## @param master.persistence.accessModes Persistent Volume access modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param master.persistence.size Persistent Volume size
    ##
    size: 8Gi
    ## @param master.persistence.annotations Additional custom annotations for the PVC
    ##
    annotations: {}
    ## @param master.persistence.selector Additional labels to match for the PVC
    ## e.g:
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param master.persistence.dataSource Custom PVC data source
    ##
    dataSource: {}
    ## @param master.persistence.existingClaim Use a existing PVC which must be created manually before bound
    ## NOTE: requires master.persistence.enabled: true
    ##
    existingClaim: ""
  ## Redis&reg; master service parameters
  ##
  service:
    ## @param master.service.type Redis&reg; master service type
    ##
    type: ClusterIP
    ## @param master.service.ports.redis Redis&reg; master service port
    ##
    ports:
      redis: 6379
    ## @param master.service.nodePorts.redis Node port for Redis&reg; master
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ## NOTE: choose port between <30000-32767>
    ##
    nodePorts:
      redis: ""
    ## @param master.service.externalTrafficPolicy Redis&reg; master service external traffic policy
    ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
    ##
    externalTrafficPolicy: Cluster
    ## @param master.service.extraPorts Extra ports to expose (normally used with the \$(sidecar) value)
    ##
    extraPorts: []
    ## @param master.service.internalTrafficPolicy Redis&reg; master service internal traffic policy (requires Kubernetes v1.22 or greater to be usable)
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    ##
    internalTrafficPolicy: Cluster
    ## @param master.service.clusterIP Redis&reg; master service Cluster IP
    ##
    clusterIP: ""
    ## @param master.service.loadBalancerIP Redis&reg; master service Load Balancer IP
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    loadBalancerIP: ""
    ## @param master.service.loadBalancerSourceRanges Redis&reg; master service Load Balancer sources
    ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ## e.g.
    ## loadBalancerSourceRanges:
    ##   - 10.10.10.0/24
    ##
    loadBalancerSourceRanges: []
    ## @param master.service.externalIPs Redis&reg; master service External IPs
    ## https://kubernetes.io/docs/concepts/services-networking/service/#external-ips
    ## e.g.
    ## externalIPs:
    ##   - 10.10.10.1
    ##   - 201.22.30.1
    ##
    externalIPs: []
    ## @param master.service.annotations Additional custom annotations for Redis&reg; master service
    ##
    annotations: {}
    ## @param master.service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
    ## If "ClientIP", consecutive client requests will be directed to the same Pod
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    ##
    sessionAffinity: None
    ## @param master.service.sessionAffinityConfig Additional settings for the sessionAffinity
    ## sessionAffinityConfig:
    ##   clientIP:
    ##     timeoutSeconds: 300
    ##
    sessionAffinityConfig: {}
  ## @param master.terminationGracePeriodSeconds Integer setting the termination grace period for the redis-master pods
  ##
  terminationGracePeriodSeconds: 30
  ## ServiceAccount configuration
  ##
  serviceAccount:
    ## @param master.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param master.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param master.serviceAccount.automountServiceAccountToken Whether to auto mount the service account token
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server
    ##
    automountServiceAccountToken: true
    ## @param master.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}

## @section Redis&reg; replicas configuration parameters
##

replica:
  ## @param replica.replicaCount Number of Redis&reg; replicas to deploy
  ##
  replicaCount: 3
  ## @param replica.configuration Configuration for Redis&reg; replicas nodes
  ## ref: https://redis.io/topics/config
  ##
  configuration: ""
  ## @param replica.disableCommands Array with Redis&reg; commands to disable on replicas nodes
  ## Commands will be completely disabled by renaming each to an empty string.
  ## ref: https://redis.io/topics/security#disabling-of-specific-commands
  ##
  disableCommands:
    - FLUSHDB
    - FLUSHALL
  ## @param replica.command Override default container command (useful when using custom images)
  ##
  command: []
  ## @param replica.args Override default container args (useful when using custom images)
  ##
  args: []
  ## @param replica.preExecCmds Additional commands to run prior to starting Redis&reg; replicas
  ##
  preExecCmds: []
  ## @param replica.extraFlags Array with additional command line flags for Redis&reg; replicas
  ## e.g:
  ## extraFlags:
  ##  - "--maxmemory-policy volatile-ttl"
  ##  - "--repl-backlog-size 1024mb"
  ##
  extraFlags: []
  ## @param replica.extraEnvVars Array with extra environment variables to add to Redis&reg; replicas nodes
  ## e.g:
  ## extraEnvVars:
  ##   - name: FOO
  ##     value: "bar"
  ##
  extraEnvVars: []
  ## @param replica.extraEnvVarsCM Name of existing ConfigMap containing extra env vars for Redis&reg; replicas nodes
  ##
  extraEnvVarsCM: ""
  ## @param replica.extraEnvVarsSecret Name of existing Secret containing extra env vars for Redis&reg; replicas nodes
  ##
  extraEnvVarsSecret: ""
  ## @param replica.externalMaster.enabled Use external master for bootstrapping
  ## @param replica.externalMaster.host External master host to bootstrap from
  ## @param replica.externalMaster.port Port for Redis service external master host
  ##
  externalMaster:
    enabled: false
    host: ""
    port: 6379
  ## @param replica.containerPorts.redis Container port to open on Redis&reg; replicas nodes
  ##
  containerPorts:
    redis: 6379
  ## Configure extra options for Redis&reg; containers' liveness and readiness probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
  ## @param replica.startupProbe.enabled Enable startupProbe on Redis&reg; replicas nodes
  ## @param replica.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
  ## @param replica.startupProbe.periodSeconds Period seconds for startupProbe
  ## @param replica.startupProbe.timeoutSeconds Timeout seconds for startupProbe
  ## @param replica.startupProbe.failureThreshold Failure threshold for startupProbe
  ## @param replica.startupProbe.successThreshold Success threshold for startupProbe
  ##
  startupProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 22
  ## @param replica.livenessProbe.enabled Enable livenessProbe on Redis&reg; replicas nodes
  ## @param replica.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
  ## @param replica.livenessProbe.periodSeconds Period seconds for livenessProbe
  ## @param replica.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
  ## @param replica.livenessProbe.failureThreshold Failure threshold for livenessProbe
  ## @param replica.livenessProbe.successThreshold Success threshold for livenessProbe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  ## @param replica.readinessProbe.enabled Enable readinessProbe on Redis&reg; replicas nodes
  ## @param replica.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
  ## @param replica.readinessProbe.periodSeconds Period seconds for readinessProbe
  ## @param replica.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
  ## @param replica.readinessProbe.failureThreshold Failure threshold for readinessProbe
  ## @param replica.readinessProbe.successThreshold Success threshold for readinessProbe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 5
  ## @param replica.customStartupProbe Custom startupProbe that overrides the default one
  ##
  customStartupProbe: {}
  ## @param replica.customLivenessProbe Custom livenessProbe that overrides the default one
  ##
  customLivenessProbe: {}
  ## @param replica.customReadinessProbe Custom readinessProbe that overrides the default one
  ##
  customReadinessProbe: {}
  ## Redis&reg; replicas resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## @param replica.resources.limits The resources limits for the Redis&reg; replicas containers
  ## @param replica.resources.requests The requested resources for the Redis&reg; replicas containers
  ##
  resources:
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    limits: 
       cpu: 250m
       memory: 256Mi
    requests: 
       cpu: 250m
       memory: 256Mi
  ## Configure Pods Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param replica.podSecurityContext.enabled Enabled Redis&reg; replicas pods' Security Context
  ## @param replica.podSecurityContext.fsGroup Set Redis&reg; replicas pod's Security Context fsGroup
  ##
  podSecurityContext:
    enabled: true
    fsGroup: 1001
  ## Configure Container Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param replica.containerSecurityContext.enabled Enabled Redis&reg; replicas containers' Security Context
  ## @param replica.containerSecurityContext.runAsUser Set Redis&reg; replicas containers' Security Context runAsUser
  ##
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  ## @param replica.schedulerName Alternate scheduler for Redis&reg; replicas pods
  ## ref: https://kubernetes.io/docs/tasks/administer-cluster/configure-multiple-schedulers/
  ##
  schedulerName: ""
  ## @param replica.updateStrategy.type Redis&reg; replicas statefulset strategy type
  ## @skip replica.updateStrategy.rollingUpdate
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#update-strategies
  ##
  updateStrategy:
    ## StrategyType
    ## Can be set to RollingUpdate, OnDelete (statefulset), Recreate (deployment)
    ##
    type: RollingUpdate
  ## @param replica.minReadySeconds How many seconds a pod needs to be ready before killing the next, during update
  ##
  minReadySeconds: 0
  ## @param replica.priorityClassName Redis&reg; replicas pods' priorityClassName
  ##
  priorityClassName: ""
  ## @param replica.podManagementPolicy podManagementPolicy to manage scaling operation of %%MAIN_CONTAINER_NAME%% pods
  ## ref: https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/#pod-management-policies
  ##
  podManagementPolicy: ""
  ## @param replica.hostAliases Redis&reg; replicas pods host aliases
  ## https://kubernetes.io/docs/concepts/services-networking/add-entries-to-pod-etc-hosts-with-host-aliases/
  ##
  hostAliases: []
  ## @param replica.podLabels Extra labels for Redis&reg; replicas pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## @param replica.podAnnotations Annotations for Redis&reg; replicas pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations: {}
  ## @param replica.shareProcessNamespace Share a single process namespace between all of the containers in Redis&reg; replicas pods
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/share-process-namespace/
  ##
  shareProcessNamespace: false
  ## @param replica.podAffinityPreset Pod affinity preset. Ignored if \$(replica.affinity) is set. Allowed values: \$(soft) or \$(hard)
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ##
  podAffinityPreset: ""
  ## @param replica.podAntiAffinityPreset Pod anti-affinity preset. Ignored if \$(replica.affinity) is set. Allowed values: \$(soft) or \$(hard)
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#inter-pod-affinity-and-anti-affinity
  ##
  podAntiAffinityPreset: soft
  ## Node affinity preset
  ## ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#node-affinity
  ##
  nodeAffinityPreset:
    ## @param replica.nodeAffinityPreset.type Node affinity preset type. Ignored if \$(replica.affinity) is set. Allowed values: \$(soft) or \$(hard)
    ##
    type: ""
    ## @param replica.nodeAffinityPreset.key Node label key to match. Ignored if \$(replica.affinity) is set
    ##
    key: ""
    ## @param replica.nodeAffinityPreset.values Node label values to match. Ignored if \$(replica.affinity) is set
    ## E.g.
    ## values:
    ##   - e2e-az1
    ##   - e2e-az2
    ##
    values: []
  ## @param replica.affinity Affinity for Redis&reg; replicas pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity
  ## NOTE: \$(replica.podAffinityPreset), \$(replica.podAntiAffinityPreset), and \$(replica.nodeAffinityPreset) will be ignored when it's set
  ##
  affinity: {}
  ## @param replica.nodeSelector Node labels for Redis&reg; replicas pods assignment
  ## ref: https://kubernetes.io/docs/user-guide/node-selection/
  ##
  nodeSelector: {}
  ## @param replica.tolerations Tolerations for Redis&reg; replicas pods assignment
  ## ref: https://kubernetes.io/docs/concepts/configuration/taint-and-toleration/
  ##
  tolerations: []
  ## @param replica.topologySpreadConstraints Spread Constraints for Redis&reg; replicas pod assignment
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/
  ## E.g.
  ## topologySpreadConstraints:
  ##   - maxSkew: 1
  ##     topologyKey: node
  ##     whenUnsatisfiable: DoNotSchedule
  ##
  topologySpreadConstraints: []
  ## @param replica.dnsPolicy DNS Policy for Redis&reg; replica pods
  ## ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
  ## E.g.
  ## dnsPolicy: ClusterFirst
  dnsPolicy: ""
  ## @param replica.dnsConfig DNS Configuration for Redis&reg; replica pods
  ## ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
  ## E.g.
  ## dnsConfig:
  ##   options:
  ##   - name: ndots
  ##     value: "4"
  ##   - name: single-request-reopen
  dnsConfig: {}
  ## @param replica.lifecycleHooks for the Redis&reg; replica container(s) to automate configuration before or after startup
  ##
  lifecycleHooks: {}
  ## @param replica.extraVolumes Optionally specify extra list of additional volumes for the Redis&reg; replicas pod(s)
  ##
  extraVolumes: []
  ## @param replica.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the Redis&reg; replicas container(s)
  ##
  extraVolumeMounts: []
  ## @param replica.sidecars Add additional sidecar containers to the Redis&reg; replicas pod(s)
  ## e.g:
  ## sidecars:
  ##   - name: your-image-name
  ##     image: your-image
  ##     imagePullPolicy: Always
  ##     ports:
  ##       - name: portname
  ##         containerPort: 1234
  ##
  sidecars: []
  ## @param replica.initContainers Add additional init containers to the Redis&reg; replicas pod(s)
  ## ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
  ## e.g:
  ## initContainers:
  ##  - name: your-image-name
  ##    image: your-image
  ##    imagePullPolicy: Always
  ##    command: ['sh', '-c', 'echo "hello world"']
  ##
  initContainers: []
  ## Persistence Parameters
  ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    ## @param replica.persistence.enabled Enable persistence on Redis&reg; replicas nodes using Persistent Volume Claims
    ##
    enabled: true
    ## @param replica.persistence.medium Provide a medium for \$(emptyDir) volumes.
    ##
    medium: ""
    ## @param replica.persistence.sizeLimit Set this to enable a size limit for \$(emptyDir) volumes.
    ##
    sizeLimit: ""
    ##  @param replica.persistence.path The path the volume will be mounted at on Redis&reg; replicas containers
    ## NOTE: Useful when using different Redis&reg; images
    ##
    path: /data
    ## @param replica.persistence.subPath The subdirectory of the volume to mount on Redis&reg; replicas containers
    ## NOTE: Useful in dev environments
    ##
    subPath: ""
    ## @param replica.persistence.subPathExpr Used to construct the subPath subdirectory of the volume to mount on Redis&reg; replicas containers
    ##
    subPathExpr: ""
    ## @param replica.persistence.storageClass Persistent Volume storage class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner
    ##
    storageClass: ""
    ## @param replica.persistence.accessModes Persistent Volume access modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param replica.persistence.size Persistent Volume size
    ##
    size: 8Gi
    ## @param replica.persistence.annotations Additional custom annotations for the PVC
    ##
    annotations: {}
    ## @param replica.persistence.selector Additional labels to match for the PVC
    ## e.g:
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param replica.persistence.dataSource Custom PVC data source
    ##
    dataSource: {}
    ## @param replica.persistence.existingClaim Use a existing PVC which must be created manually before bound
    ## NOTE: requires replica.persistence.enabled: true
    ##
    existingClaim: ""
  ## Redis&reg; replicas service parameters
  ##
  service:
    ## @param replica.service.type Redis&reg; replicas service type
    ##
    type: ClusterIP
    ## @param replica.service.ports.redis Redis&reg; replicas service port
    ##
    ports:
      redis: 6379
    ## @param replica.service.nodePorts.redis Node port for Redis&reg; replicas
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ## NOTE: choose port between <30000-32767>
    ##
    nodePorts:
      redis: ""
    ## @param replica.service.externalTrafficPolicy Redis&reg; replicas service external traffic policy
    ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
    ##
    externalTrafficPolicy: Cluster
    ## @param replica.service.internalTrafficPolicy Redis&reg; replicas service internal traffic policy (requires Kubernetes v1.22 or greater to be usable)
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service-traffic-policy/
    ##
    internalTrafficPolicy: Cluster
    ## @param replica.service.extraPorts Extra ports to expose (normally used with the \$(sidecar) value)
    ##
    extraPorts: []
    ## @param replica.service.clusterIP Redis&reg; replicas service Cluster IP
    ##
    clusterIP: ""
    ## @param replica.service.loadBalancerIP Redis&reg; replicas service Load Balancer IP
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    loadBalancerIP: ""
    ## @param replica.service.loadBalancerSourceRanges Redis&reg; replicas service Load Balancer sources
    ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ## e.g.
    ## loadBalancerSourceRanges:
    ##   - 10.10.10.0/24
    ##
    loadBalancerSourceRanges: []
    ## @param replica.service.annotations Additional custom annotations for Redis&reg; replicas service
    ##
    annotations: {}
    ## @param replica.service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
    ## If "ClientIP", consecutive client requests will be directed to the same Pod
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    ##
    sessionAffinity: None
    ## @param replica.service.sessionAffinityConfig Additional settings for the sessionAffinity
    ## sessionAffinityConfig:
    ##   clientIP:
    ##     timeoutSeconds: 300
    ##
    sessionAffinityConfig: {}
  ## @param replica.terminationGracePeriodSeconds Integer setting the termination grace period for the redis-replicas pods
  ##
  terminationGracePeriodSeconds: 30
  ## Autoscaling configuration
  ##
  autoscaling:
    ## @param replica.autoscaling.enabled Enable replica autoscaling settings
    ##
    enabled: false
    ## @param replica.autoscaling.minReplicas Minimum replicas for the pod autoscaling
    ##
    minReplicas: 1
    ## @param replica.autoscaling.maxReplicas Maximum replicas for the pod autoscaling
    ##
    maxReplicas: 11
    ## @param replica.autoscaling.targetCPU Percentage of CPU to consider when autoscaling
    ##
    targetCPU: ""
    ## @param replica.autoscaling.targetMemory Percentage of Memory to consider when autoscaling
    ##
    targetMemory: ""
  ## ServiceAccount configuration
  ##
  serviceAccount:
    ## @param replica.serviceAccount.create Specifies whether a ServiceAccount should be created
    ##
    create: false
    ## @param replica.serviceAccount.name The name of the ServiceAccount to use.
    ## If not set and create is true, a name is generated using the common.names.fullname template
    ##
    name: ""
    ## @param replica.serviceAccount.automountServiceAccountToken Whether to auto mount the service account token
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server
    ##
    automountServiceAccountToken: true
    ## @param replica.serviceAccount.annotations Additional custom annotations for the ServiceAccount
    ##
    annotations: {}
## @section Redis&reg; Sentinel configuration parameters
##

sentinel:
  ## @param sentinel.enabled Use Redis&reg; Sentinel on Redis&reg; pods.
  ## IMPORTANT: this will disable the master and replicas services and
  ## create a single Redis&reg; service exposing both the Redis and Sentinel ports
  ##
  enabled: true
  ## Bitnami Redis&reg; Sentinel image version
  ## ref: https://hub.docker.com/r/bitnami/redis-sentinel/tags/
  ## @param sentinel.image.registry Redis&reg; Sentinel image registry
  ## @param sentinel.image.repository Redis&reg; Sentinel image repository
  ## @param sentinel.image.tag Redis&reg; Sentinel image tag (immutable tags are recommended)
  ## @param sentinel.image.digest Redis&reg; Sentinel image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param sentinel.image.pullPolicy Redis&reg; Sentinel image pull policy
  ## @param sentinel.image.pullSecrets Redis&reg; Sentinel image pull secrets
  ## @param sentinel.image.debug Enable image debug mode
  ##
  image:
    registry: docker.io
    repository: bitnami/redis-sentinel
    tag: 7.0.8-debian-11-r11
    digest: ""
    ## Specify a imagePullPolicy
    ## Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    ## ref: https://kubernetes.io/docs/user-guide/images/#pre-pulling-images
    ##
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
    ## Enable debug mode
    ##
    debug: false
  ## @param sentinel.masterSet Master set name
  ##
  masterSet: mymaster
  ## @param sentinel.quorum Sentinel Quorum
  ##
  quorum: 2
  ## @param sentinel.getMasterTimeout Amount of time to allow before get_sentinel_master_info() times out.
  ## NOTE: This is directly related to the startupProbes which are configured to run every 10 seconds for a total of 22 failures. If adjusting this value, also adjust the startupProbes.
  getMasterTimeout: 220
  ## @param sentinel.automateClusterRecovery Automate cluster recovery in cases where the last replica is not considered a good replica and Sentinel won't automatically failover to it.
  ## This also prevents any new replica from starting until the last remaining replica is elected as master to guarantee that it is the one to be elected by Sentinel, and not a newly started replica with no data.
  ## NOTE: This feature requires a "downAfterMilliseconds" value less or equal to 2000.
  ##
  automateClusterRecovery: true
  ## @param sentinel.redisShutdownWaitFailover Whether the Redis&reg; master container waits for the failover at shutdown (in addition to the Redis&reg; Sentinel container).
  redisShutdownWaitFailover: true
  ## Sentinel timing restrictions
  ## @param sentinel.downAfterMilliseconds Timeout for detecting a Redis&reg; node is down
  ## @param sentinel.failoverTimeout Timeout for performing a election failover
  ##
  downAfterMilliseconds: 2000
  failoverTimeout: 180000
  ## @param sentinel.parallelSyncs Number of replicas that can be reconfigured in parallel to use the new master after a failover
  ##
  parallelSyncs: 1
  ## @param sentinel.configuration Configuration for Redis&reg; Sentinel nodes
  ## ref: https://redis.io/topics/sentinel
  ##
  configuration: ""
  ## @param sentinel.command Override default container command (useful when using custom images)
  ##
  command: []
  ## @param sentinel.args Override default container args (useful when using custom images)
  ##
  args: []
  ## @param sentinel.preExecCmds Additional commands to run prior to starting Redis&reg; Sentinel
  ##
  preExecCmds: []
  ## @param sentinel.extraEnvVars Array with extra environment variables to add to Redis&reg; Sentinel nodes
  ## e.g:
  ## extraEnvVars:
  ##   - name: FOO
  ##     value: "bar"
  ##
  extraEnvVars: []
  ## @param sentinel.extraEnvVarsCM Name of existing ConfigMap containing extra env vars for Redis&reg; Sentinel nodes
  ##
  extraEnvVarsCM: ""
  ## @param sentinel.extraEnvVarsSecret Name of existing Secret containing extra env vars for Redis&reg; Sentinel nodes
  ##
  extraEnvVarsSecret: ""
  ## @param sentinel.externalMaster.enabled Use external master for bootstrapping
  ## @param sentinel.externalMaster.host External master host to bootstrap from
  ## @param sentinel.externalMaster.port Port for Redis service external master host
  ##
  externalMaster:
    enabled: false
    host: ""
    port: 6379
  ## @param sentinel.containerPorts.sentinel Container port to open on Redis&reg; Sentinel nodes
  ##
  containerPorts:
    sentinel: 26379
  ## Configure extra options for Redis&reg; containers' liveness and readiness probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-probes/#configure-probes
  ## @param sentinel.startupProbe.enabled Enable startupProbe on Redis&reg; Sentinel nodes
  ## @param sentinel.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
  ## @param sentinel.startupProbe.periodSeconds Period seconds for startupProbe
  ## @param sentinel.startupProbe.timeoutSeconds Timeout seconds for startupProbe
  ## @param sentinel.startupProbe.failureThreshold Failure threshold for startupProbe
  ## @param sentinel.startupProbe.successThreshold Success threshold for startupProbe
  ##
  startupProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 22
  ## @param sentinel.livenessProbe.enabled Enable livenessProbe on Redis&reg; Sentinel nodes
  ## @param sentinel.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
  ## @param sentinel.livenessProbe.periodSeconds Period seconds for livenessProbe
  ## @param sentinel.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
  ## @param sentinel.livenessProbe.failureThreshold Failure threshold for livenessProbe
  ## @param sentinel.livenessProbe.successThreshold Success threshold for livenessProbe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  ## @param sentinel.readinessProbe.enabled Enable readinessProbe on Redis&reg; Sentinel nodes
  ## @param sentinel.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
  ## @param sentinel.readinessProbe.periodSeconds Period seconds for readinessProbe
  ## @param sentinel.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
  ## @param sentinel.readinessProbe.failureThreshold Failure threshold for readinessProbe
  ## @param sentinel.readinessProbe.successThreshold Success threshold for readinessProbe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 20
    periodSeconds: 5
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 5
  ## @param sentinel.customStartupProbe Custom startupProbe that overrides the default one
  ##
  customStartupProbe: {}
  ## @param sentinel.customLivenessProbe Custom livenessProbe that overrides the default one
  ##
  customLivenessProbe: {}
  ## @param sentinel.customReadinessProbe Custom readinessProbe that overrides the default one
  ##
  customReadinessProbe: {}
  ## Persistence parameters
  ## ref: https://kubernetes.io/docs/user-guide/persistent-volumes/
  ##
  persistence:
    ## @param sentinel.persistence.enabled Enable persistence on Redis&reg; sentinel nodes using Persistent Volume Claims (Experimental)
    ##
    enabled: true
    ## @param sentinel.persistence.storageClass Persistent Volume storage class
    ## If defined, storageClassName: <storageClass>
    ## If set to "-", storageClassName: "", which disables dynamic provisioning
    ## If undefined (the default) or set to null, no storageClassName spec is set, choosing the default provisioner
    ##
    storageClass: ""
    ## @param sentinel.persistence.accessModes Persistent Volume access modes
    ##
    accessModes:
      - ReadWriteOnce
    ## @param sentinel.persistence.size Persistent Volume size
    ##
    size: 100Mi
    ## @param sentinel.persistence.annotations Additional custom annotations for the PVC
    ##
    annotations: {}
    ## @param sentinel.persistence.selector Additional labels to match for the PVC
    ## e.g:
    ## selector:
    ##   matchLabels:
    ##     app: my-app
    ##
    selector: {}
    ## @param sentinel.persistence.dataSource Custom PVC data source
    ##
    dataSource: {}
    ## @param sentinel.persistence.medium Provide a medium for \$(emptyDir) volumes.
    ##
    medium: ""
    ## @param sentinel.persistence.sizeLimit Set this to enable a size limit for \$(emptyDir) volumes.
    ##
    sizeLimit: ""
  ## Redis&reg; Sentinel resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## @param sentinel.resources.limits The resources limits for the Redis&reg; Sentinel containers
  ## @param sentinel.resources.requests The requested resources for the Redis&reg; Sentinel containers
  ##
  resources:
    limits: {}
    requests: {}
  ## Configure Container Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param sentinel.containerSecurityContext.enabled Enabled Redis&reg; Sentinel containers' Security Context
  ## @param sentinel.containerSecurityContext.runAsUser Set Redis&reg; Sentinel containers' Security Context runAsUser
  ##
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  ## @param sentinel.lifecycleHooks for the Redis&reg; sentinel container(s) to automate configuration before or after startup
  ##
  lifecycleHooks: {}
  ## @param sentinel.extraVolumes Optionally specify extra list of additional volumes for the Redis&reg; Sentinel
  ##
  extraVolumes: []
  ## @param sentinel.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the Redis&reg; Sentinel container(s)
  ##
  extraVolumeMounts: []
  ## Redis&reg; Sentinel service parameters
  ##
  service:
    ## @param sentinel.service.type Redis&reg; Sentinel service type
    ##
    type: ClusterIP
    ## @param sentinel.service.ports.redis Redis&reg; service port for Redis&reg;
    ## @param sentinel.service.ports.sentinel Redis&reg; service port for Redis&reg; Sentinel
    ##
    ports:
      redis: 6379
      sentinel: 26379
    ## @param sentinel.service.nodePorts.redis Node port for Redis&reg;
    ## @param sentinel.service.nodePorts.sentinel Node port for Sentinel
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#type-nodeport
    ## NOTE: choose port between <30000-32767>
    ## NOTE: By leaving these values blank, they will be generated by ports-configmap
    ##       If setting manually, please leave at least replica.replicaCount + 1 in between sentinel.service.nodePorts.redis and sentinel.service.nodePorts.sentinel to take into account the ports that will be created while incrementing that base port
    ##
    nodePorts:
      redis: ""
      sentinel: ""
    ## @param sentinel.service.externalTrafficPolicy Redis&reg; Sentinel service external traffic policy
    ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
    ##
    externalTrafficPolicy: Cluster
    ## @param sentinel.service.extraPorts Extra ports to expose (normally used with the \$(sidecar) value)
    ##
    extraPorts: []
    ## @param sentinel.service.clusterIP Redis&reg; Sentinel service Cluster IP
    ##
    clusterIP: ""
    ## @param sentinel.service.loadBalancerIP Redis&reg; Sentinel service Load Balancer IP
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    loadBalancerIP: ""
    ## @param sentinel.service.loadBalancerSourceRanges Redis&reg; Sentinel service Load Balancer sources
    ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ## e.g.
    ## loadBalancerSourceRanges:
    ##   - 10.10.10.0/24
    ##
    loadBalancerSourceRanges: []
    ## @param sentinel.service.annotations Additional custom annotations for Redis&reg; Sentinel service
    ##
    annotations: {}
    ## @param sentinel.service.sessionAffinity Session Affinity for Kubernetes service, can be "None" or "ClientIP"
    ## If "ClientIP", consecutive client requests will be directed to the same Pod
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
    ##
    sessionAffinity: None
    ## @param sentinel.service.sessionAffinityConfig Additional settings for the sessionAffinity
    ## sessionAffinityConfig:
    ##   clientIP:
    ##     timeoutSeconds: 300
    ##
    sessionAffinityConfig: {}
  ## @param sentinel.terminationGracePeriodSeconds Integer setting the termination grace period for the redis-node pods
  ##
  terminationGracePeriodSeconds: 30

## @section Other Parameters
##

## Network Policy configuration
## ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
##
networkPolicy:
  ## @param networkPolicy.enabled Enable creation of NetworkPolicy resources
  ##
  enabled: false
  ## @param networkPolicy.allowExternal Don't require client label for connections
  ## When set to false, only pods with the correct client label will have network access to the ports
  ## Redis&reg; is listening on. When true, Redis&reg; will accept connections from any source
  ## (with the correct destination port).
  ##
  allowExternal: true
  ## @param networkPolicy.extraIngress Add extra ingress rules to the NetworkPolicy
  ## e.g:
  ## extraIngress:
  ##   - ports:
  ##       - port: 1234
  ##     from:
  ##       - podSelector:
  ##           - matchLabels:
  ##               - role: frontend
  ##       - podSelector:
  ##           - matchExpressions:
  ##               - key: role
  ##                 operator: In
  ##                 values:
  ##                   - frontend
  ##
  extraIngress: []
  ## @param networkPolicy.extraEgress Add extra egress rules to the NetworkPolicy
  ## e.g:
  ## extraEgress:
  ##   - ports:
  ##       - port: 1234
  ##     to:
  ##       - podSelector:
  ##           - matchLabels:
  ##               - role: frontend
  ##       - podSelector:
  ##           - matchExpressions:
  ##               - key: role
  ##                 operator: In
  ##                 values:
  ##                   - frontend
  ##
  extraEgress: []
  ## @param networkPolicy.ingressNSMatchLabels Labels to match to allow traffic from other namespaces
  ## @param networkPolicy.ingressNSPodMatchLabels Pod labels to match to allow traffic from other namespaces
  ##
  ingressNSMatchLabels: {}
  ingressNSPodMatchLabels: {}
## PodSecurityPolicy configuration
## ref: https://kubernetes.io/docs/concepts/policy/pod-security-policy/
##
podSecurityPolicy:
  ## @param podSecurityPolicy.create Whether to create a PodSecurityPolicy. WARNING: PodSecurityPolicy is deprecated in Kubernetes v1.21 or later, unavailable in v1.25 or later
  ##
  create: false
  ## @param podSecurityPolicy.enabled Enable PodSecurityPolicy's RBAC rules
  ##
  enabled: false
## RBAC configuration
##
rbac:
  ## @param rbac.create Specifies whether RBAC resources should be created
  ##
  create: false
  ## @param rbac.rules Custom RBAC rules to set
  ## e.g:
  ## rules:
  ##   - apiGroups:
  ##       - ""
  ##     resources:
  ##       - pods
  ##     verbs:
  ##       - get
  ##       - list
  ##
  rules: []
## ServiceAccount configuration
##
serviceAccount:
  ## @param serviceAccount.create Specifies whether a ServiceAccount should be created
  ##
  create: true
  ## @param serviceAccount.name The name of the ServiceAccount to use.
  ## If not set and create is true, a name is generated using the common.names.fullname template
  ##
  name: ""
  ## @param serviceAccount.automountServiceAccountToken Whether to auto mount the service account token
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/#use-the-default-service-account-to-access-the-api-server
  ##
  automountServiceAccountToken: true
  ## @param serviceAccount.annotations Additional custom annotations for the ServiceAccount
  ##
  annotations: {}
## Redis&reg; Pod Disruption Budget configuration
## ref: https://kubernetes.io/docs/tasks/run-application/configure-pdb/
##
pdb:
  ## @param pdb.create Specifies whether a PodDisruptionBudget should be created
  ##
  create: false
  ## @param pdb.minAvailable Min number of pods that must still be available after the eviction
  ##
  minAvailable: 1
  ## @param pdb.maxUnavailable Max number of pods that can be unavailable after the eviction
  ##
  maxUnavailable: ""
## TLS configuration
##
tls:
  ## @param tls.enabled Enable TLS traffic
  ##
  enabled: false
  ## @param tls.authClients Require clients to authenticate
  ##
  authClients: true
  ## @param tls.autoGenerated Enable autogenerated certificates
  ##
  autoGenerated: false
  ## @param tls.existingSecret The name of the existing secret that contains the TLS certificates
  ##
  existingSecret: ""
  ## @param tls.certificatesSecret DEPRECATED. Use existingSecret instead.
  ##
  certificatesSecret: ""
  ## @param tls.certFilename Certificate filename
  ##
  certFilename: ""
  ## @param tls.certKeyFilename Certificate Key filename
  ##
  certKeyFilename: ""
  ## @param tls.certCAFilename CA Certificate filename
  ##
  certCAFilename: ""
  ## @param tls.dhParamsFilename File containing DH params (in order to support DH based ciphers)
  ##
  dhParamsFilename: ""

## @section Metrics Parameters
##

metrics:
  ## @param metrics.enabled Start a sidecar prometheus exporter to expose Redis&reg; metrics
  ##
  enabled: false
  ## Bitnami Redis&reg; Exporter image
  ## ref: https://hub.docker.com/r/bitnami/redis-exporter/tags/
  ## @param metrics.image.registry Redis&reg; Exporter image registry
  ## @param metrics.image.repository Redis&reg; Exporter image repository
  ## @param metrics.image.tag Redis&reg; Exporter image tag (immutable tags are recommended)
  ## @param metrics.image.digest Redis&reg; Exporter image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param metrics.image.pullPolicy Redis&reg; Exporter image pull policy
  ## @param metrics.image.pullSecrets Redis&reg; Exporter image pull secrets
  ##
  image:
    registry: docker.io
    repository: bitnami/redis-exporter
    tag: 1.46.0-debian-11-r5
    digest: ""
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  ## Configure extra options for Redis&reg; containers' liveness, readiness & startup probes
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/
  ## @param metrics.startupProbe.enabled Enable startupProbe on Redis&reg; replicas nodes
  ## @param metrics.startupProbe.initialDelaySeconds Initial delay seconds for startupProbe
  ## @param metrics.startupProbe.periodSeconds Period seconds for startupProbe
  ## @param metrics.startupProbe.timeoutSeconds Timeout seconds for startupProbe
  ## @param metrics.startupProbe.failureThreshold Failure threshold for startupProbe
  ## @param metrics.startupProbe.successThreshold Success threshold for startupProbe
  ##
  startupProbe:
    enabled: false
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  ## @param metrics.livenessProbe.enabled Enable livenessProbe on Redis&reg; replicas nodes
  ## @param metrics.livenessProbe.initialDelaySeconds Initial delay seconds for livenessProbe
  ## @param metrics.livenessProbe.periodSeconds Period seconds for livenessProbe
  ## @param metrics.livenessProbe.timeoutSeconds Timeout seconds for livenessProbe
  ## @param metrics.livenessProbe.failureThreshold Failure threshold for livenessProbe
  ## @param metrics.livenessProbe.successThreshold Success threshold for livenessProbe
  ##
  livenessProbe:
    enabled: true
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    successThreshold: 1
    failureThreshold: 5
  ## @param metrics.readinessProbe.enabled Enable readinessProbe on Redis&reg; replicas nodes
  ## @param metrics.readinessProbe.initialDelaySeconds Initial delay seconds for readinessProbe
  ## @param metrics.readinessProbe.periodSeconds Period seconds for readinessProbe
  ## @param metrics.readinessProbe.timeoutSeconds Timeout seconds for readinessProbe
  ## @param metrics.readinessProbe.failureThreshold Failure threshold for readinessProbe
  ## @param metrics.readinessProbe.successThreshold Success threshold for readinessProbe
  ##
  readinessProbe:
    enabled: true
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 1
    successThreshold: 1
    failureThreshold: 3
  ## @param metrics.customStartupProbe Custom startupProbe that overrides the default one
  ##
  customStartupProbe: {}
  ## @param metrics.customLivenessProbe Custom livenessProbe that overrides the default one
  ##
  customLivenessProbe: {}
  ## @param metrics.customReadinessProbe Custom readinessProbe that overrides the default one
  ##
  customReadinessProbe: {}
  ## @param metrics.command Override default metrics container init command (useful when using custom images)
  ##
  command: []
  ## @param metrics.redisTargetHost A way to specify an alternative Redis&reg; hostname
  ## Useful for certificate CN/SAN matching
  ##
  redisTargetHost: "localhost"
  ## @param metrics.extraArgs Extra arguments for Redis&reg; exporter, for example:
  ## e.g.:
  ## extraArgs:
  ##   check-keys: myKey,myOtherKey
  ##
  extraArgs: {}
  ## @param metrics.extraEnvVars Array with extra environment variables to add to Redis&reg; exporter
  ## e.g:
  ## extraEnvVars:
  ##   - name: FOO
  ##     value: "bar"
  ##
  extraEnvVars: []
  ## Configure Container Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  ## @param metrics.containerSecurityContext.enabled Enabled Redis&reg; exporter containers' Security Context
  ## @param metrics.containerSecurityContext.runAsUser Set Redis&reg; exporter containers' Security Context runAsUser
  ##
  containerSecurityContext:
    enabled: true
    runAsUser: 1001
  ## @param metrics.extraVolumes Optionally specify extra list of additional volumes for the Redis&reg; metrics sidecar
  ##
  extraVolumes: []
  ## @param metrics.extraVolumeMounts Optionally specify extra list of additional volumeMounts for the Redis&reg; metrics sidecar
  ##
  extraVolumeMounts: []
  ## Redis&reg; exporter resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## @param metrics.resources.limits The resources limits for the Redis&reg; exporter container
  ## @param metrics.resources.requests The requested resources for the Redis&reg; exporter container
  ##
  resources:
    limits: {}
    requests: {}
  ## @param metrics.podLabels Extra labels for Redis&reg; exporter pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  ##
  podLabels: {}
  ## @param metrics.podAnnotations [object] Annotations for Redis&reg; exporter pods
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
  ##
  podAnnotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "9121"
  ## Redis&reg; exporter service parameters
  ##
  service:
    ## @param metrics.service.type Redis&reg; exporter service type
    ##
    type: ClusterIP
    ## @param metrics.service.port Redis&reg; exporter service port
    ##
    port: 9121
    ## @param metrics.service.externalTrafficPolicy Redis&reg; exporter service external traffic policy
    ## ref: https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/#preserving-the-client-source-ip
    ##
    externalTrafficPolicy: Cluster
    ## @param metrics.service.extraPorts Extra ports to expose (normally used with the \$(sidecar) value)
    ##
    extraPorts: []
    ## @param metrics.service.loadBalancerIP Redis&reg; exporter service Load Balancer IP
    ## ref: https://kubernetes.io/docs/concepts/services-networking/service/#internal-load-balancer
    ##
    loadBalancerIP: ""
    ## @param metrics.service.loadBalancerSourceRanges Redis&reg; exporter service Load Balancer sources
    ## https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/#restrict-access-for-loadbalancer-service
    ## e.g.
    ## loadBalancerSourceRanges:
    ##   - 10.10.10.0/24
    ##
    loadBalancerSourceRanges: []
    ## @param metrics.service.annotations Additional custom annotations for Redis&reg; exporter service
    ##
    annotations: {}
  ## Prometheus Service Monitor
  ## ref: https://github.com/coreos/prometheus-operator
  ##      https://github.com/coreos/prometheus-operator/blob/master/Documentation/api.md#endpoint
  ##
  serviceMonitor:
    ## @param metrics.serviceMonitor.enabled Create ServiceMonitor resource(s) for scraping metrics using PrometheusOperator
    ##
    enabled: false
    ## @param metrics.serviceMonitor.namespace The namespace in which the ServiceMonitor will be created
    ##
    namespace: ""
    ## @param metrics.serviceMonitor.interval The interval at which metrics should be scraped
    ##
    interval: 30s
    ## @param metrics.serviceMonitor.scrapeTimeout The timeout after which the scrape is ended
    ##
    scrapeTimeout: ""
    ## @param metrics.serviceMonitor.relabellings Metrics RelabelConfigs to apply to samples before scraping.
    ##
    relabellings: []
    ## @param metrics.serviceMonitor.metricRelabelings Metrics RelabelConfigs to apply to samples before ingestion.
    ##
    metricRelabelings: []
    ## @param metrics.serviceMonitor.honorLabels Specify honorLabels parameter to add the scrape endpoint
    ##
    honorLabels: false
    ## @param metrics.serviceMonitor.additionalLabels Additional labels that can be used so ServiceMonitor resource(s) can be discovered by Prometheus
    ##
    additionalLabels: {}
    ## @param metrics.serviceMonitor.podTargetLabels Labels from the Kubernetes pod to be transferred to the created metrics
    ##
    podTargetLabels: []
  ## Custom PrometheusRule to be defined
  ## ref: https://github.com/coreos/prometheus-operator#customresourcedefinitions
  ##
  prometheusRule:
    ## @param metrics.prometheusRule.enabled Create a custom prometheusRule Resource for scraping metrics using PrometheusOperator
    ##
    enabled: false
    ## @param metrics.prometheusRule.namespace The namespace in which the prometheusRule will be created
    ##
    namespace: ""
    ## @param metrics.prometheusRule.additionalLabels Additional labels for the prometheusRule
    ##
    additionalLabels: {}
    ## @param metrics.prometheusRule.rules Custom Prometheus rules
    ## e.g:
    ## rules:
    ##   - alert: RedisDown
    ##     expr: redis_up{service="{{ template "common.names.fullname" . }}-metrics"} == 0
    ##     for: 2m
    ##     labels:
    ##       severity: error
    ##     annotations:
    ##       summary: Redis&reg; instance {{ "{{ \$labels.instance }}" }} down
    ##       description: Redis&reg; instance {{ "{{ \$labels.instance }}" }} is down
    ##    - alert: RedisMemoryHigh
    ##      expr: >
    ##        redis_memory_used_bytes{service="{{ template "common.names.fullname" . }}-metrics"} * 100
    ##        /
    ##        redis_memory_max_bytes{service="{{ template "common.names.fullname" . }}-metrics"}
    ##        > 90
    ##      for: 2m
    ##      labels:
    ##        severity: error
    ##      annotations:
    ##        summary: Redis&reg; instance {{ "{{ \$labels.instance }}" }} is using too much memory
    ##        description: |
    ##          Redis&reg; instance {{ "{{ \$labels.instance }}" }} is using {{ "{{ \$value }}" }}% of its available memory.
    ##    - alert: RedisKeyEviction
    ##      expr: |
    ##        increase(redis_evicted_keys_total{service="{{ template "common.names.fullname" . }}-metrics"}[5m]) > 0
    ##      for: 1s
    ##      labels:
    ##        severity: error
    ##      annotations:
    ##        summary: Redis&reg; instance {{ "{{ \$labels.instance }}" }} has evicted keys
    ##        description: |
    ##          Redis&reg; instance {{ "{{ \$labels.instance }}" }} has evicted {{ "{{ \$value }}" }} keys in the last 5 minutes.
    ##
    rules: []

## @section Init Container Parameters
##

## 'volumePermissions' init container parameters
## Changes the owner and group of the persistent volume mount point to runAsUser:fsGroup values
##   based on the *podSecurityContext/*containerSecurityContext parameters
##
volumePermissions:
  ## @param volumePermissions.enabled Enable init container that changes the owner/group of the PV mount point to \$(runAsUser:fsGroup)
  ##
  enabled: false
  ## Bitnami Shell image
  ## ref: https://hub.docker.com/r/bitnami/bitnami-shell/tags/
  ## @param volumePermissions.image.registry Bitnami Shell image registry
  ## @param volumePermissions.image.repository Bitnami Shell image repository
  ## @param volumePermissions.image.tag Bitnami Shell image tag (immutable tags are recommended)
  ## @param volumePermissions.image.digest Bitnami Shell image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param volumePermissions.image.pullPolicy Bitnami Shell image pull policy
  ## @param volumePermissions.image.pullSecrets Bitnami Shell image pull secrets
  ##
  image:
    registry: docker.io
    repository: bitnami/bitnami-shell
    tag: 11-debian-11-r86
    digest: ""
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  ## Init container's resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## @param volumePermissions.resources.limits The resources limits for the init container
  ## @param volumePermissions.resources.requests The requested resources for the init container
  ##
  resources:
    limits: {}
    requests: {}
  ## Init container Container Security Context
  ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  ## @param volumePermissions.containerSecurityContext.runAsUser Set init container's Security Context runAsUser
  ## NOTE: when runAsUser is set to special value "auto", init container will try to chown the
  ##   data folder to auto-determined user&group, using commands: \$(id -u):\$(id -G | cut -d" " -f2)
  ##   "auto" is especially useful for OpenShift which has scc with dynamic user ids (and 0 is not allowed)
  ##
  containerSecurityContext:
    runAsUser: "auto"

## init-sysctl container parameters
## used to perform sysctl operation to modify Kernel settings (needed sometimes to avoid warnings)
##
sysctl:
  ## @param sysctl.enabled Enable init container to modify Kernel settings
  ##
  enabled: false
  ## Bitnami Shell image
  ## ref: https://hub.docker.com/r/bitnami/bitnami-shell/tags/
  ## @param sysctl.image.registry Bitnami Shell image registry
  ## @param sysctl.image.repository Bitnami Shell image repository
  ## @param sysctl.image.tag Bitnami Shell image tag (immutable tags are recommended)
  ## @param sysctl.image.digest Bitnami Shell image digest in the way sha256:aa.... Please note this parameter, if set, will override the tag
  ## @param sysctl.image.pullPolicy Bitnami Shell image pull policy
  ## @param sysctl.image.pullSecrets Bitnami Shell image pull secrets
  ##
  image:
    registry: docker.io
    repository: bitnami/bitnami-shell
    tag: 11-debian-11-r86
    digest: ""
    pullPolicy: IfNotPresent
    ## Optionally specify an array of imagePullSecrets.
    ## Secrets must be manually created in the namespace.
    ## ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    ## e.g:
    ## pullSecrets:
    ##   - myRegistryKeySecretName
    ##
    pullSecrets: []
  ## @param sysctl.command Override default init-sysctl container command (useful when using custom images)
  ##
  command: []
  ## @param sysctl.mountHostSys Mount the host \$(/sys) folder to \$(/host-sys)
  ##
  mountHostSys: false
  ## Init container's resource requests and limits
  ## ref: https://kubernetes.io/docs/user-guide/compute-resources/
  ## @param sysctl.resources.limits The resources limits for the init container
  ## @param sysctl.resources.requests The requested resources for the init container
  ##
  resources:
    limits: {}
    requests: {}

## @section useExternalDNS Parameters
##
## @param useExternalDNS.enabled Enable various syntax that would enable external-dns to work.  Note this requires a working installation of \$(external-dns) to be usable.
## @param useExternalDNS.additionalAnnotations Extra annotations to be utilized when \$(external-dns) is enabled.
## @param useExternalDNS.annotationKey The annotation key utilized when \$(external-dns) is enabled. Setting this to \$(false) will disable annotations.
## @param useExternalDNS.suffix The DNS suffix utilized when \$(external-dns) is enabled.  Note that we prepend the suffix with the full name of the release.
##
useExternalDNS:
  enabled: false
  suffix: ""
  annotationKey: external-dns.alpha.kubernetes.io/
  additionalAnnotations: {}
EOF

  # Add the helm repository and install Redis Sentinel
  helm repo add bitnami https://charts.bitnami.com/bitnami
  helm repo update-patterndb
  helm install redis bitnami/redis --values redis-values.yaml -n "$NAMESPACE"
}

installSolr() {
  # Check if Solr CRDs are already installed
  if $SOLR_EXISTS; then
    # we can install an instance of Solr
    cat >entandoSolrCloud.yaml <<EOF
apiVersion: solr.apache.org/v1beta1
kind: SolrCloud
metadata:
  name: solr
spec:
  solrAddressability:
    external:
      domainName: $KC_AUTH_URL
      method: Ingress
      useExternalAddress: true
  customSolrKubeOptions:
    ingressOptions:
      ingressClassName: "nginx"
    podOptions:
      resources:
        limits:
          memory: 1536Mi
          cpu: 500m
        requests:
          cpu: 200m
          memory: 768Mi
  dataStorage:
    persistent:
      pvcTemplate:
        spec:
          resources:
            requests:
              storage: 20Gi
      reclaimPolicy: Delete
  replicas: 3
  solrImage:
    repository: entando/entando-solr
    tag: "8"
  solrJavaMem: -Xms256M -Xmx1024M
  updateStrategy:
    method: StatefulSet
  zookeeperRef:
    provided:
      chroot: /explore
      image:
        pullPolicy: IfNotPresent
        repository: pravega/zookeeper
        tag: 0.2.13
      persistence:
        reclaimPolicy: Delete
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 2Gi
      replicas: 3
      zookeeperPodPolicy:
        resources:
          limits:
            cpu: 250m
            memory: 256Mi
          requests:
            cpu: 250m
            memory: 256Mi
EOF

    kubectl apply -f entandoSolrCloud.yaml -n "$NAMESPACE"
    sleep 120
    kubectl set env deploy/"$APP_NAME"-deployment SOLR_ACTIVE="true"
    kubectl set env deploy/"$APP_NAME"-deployment SOLR_ADDRESS="http://solr-solrcloud-common/solr"
    # Add the default `entando` core
    curl "http://$NAMESPACE-solr-solrcloud.$KC_AUTH_URL/solr/admin/collections?action=CREATE&name=entando&numShards=1&replicationFactor=3&maxShardsPerNode=2"
  else
    # We need to install the Solr operator
    helm repo add apache-solr https://solr.apache.org/charts
    helm repo update
    # Install Solr and Zookeeper CRDs
    kubectl create -f https://solr.apache.org/operator/downloads/crds/v0.5.0/all-with-dependencies.yaml
    # Install the Solr operator and Zookeeper Operator
    helm install solr-operator apache-solr/solr-operator --version 0.5.0
    cat >entandoSolrCloud.yaml <<EOF
apiVersion: solr.apache.org/v1beta1
kind: SolrCloud
metadata:
  name: solr
spec:
  solrAddressability:
    external:
      domainName: $KC_AUTH_URL
      method: Ingress
      useExternalAddress: true
  customSolrKubeOptions:
    podOptions:
      resources:
        limits:
          memory: 1536Mi
          cpu: 500m
        requests:
          cpu: 200m
          memory: 768Mi
  dataStorage:
    persistent:
      pvcTemplate:
        spec:
          resources:
            requests:
              storage: 20Gi
      reclaimPolicy: Delete
  replicas: 3
  solrImage:
    repository: entando/entando-solr
    tag: "8"
  solrJavaMem: -Xms256M -Xmx1024M
  updateStrategy:
    method: StatefulSet
  zookeeperRef:
    provided:
      chroot: /explore
      image:
        pullPolicy: IfNotPresent
        repository: pravega/zookeeper
        tag: 0.2.13
      persistence:
        reclaimPolicy: Delete
        spec:
          accessModes:
            - ReadWriteOnce
          resources:
            requests:
              storage: 2Gi
      replicas: 3
      zookeeperPodPolicy:
        resources:
          limits:
            cpu: 250m
            memory: 256Mi
          requests:
            cpu: 250m
            memory: 256Mi
EOF
    kubectl apply -f entandoSolrCloud.yaml -n "$NAMESPACE"
    echo "wait for Solr to be deployed..."
    sleep 120
    kubectl set env deploy/"$APP_NAME"-deployment SOLR_ACTIVE="true"
    kubectl set env deploy/"$APP_NAME"-deployment SOLR_ADDRESS="http://solr-solrcloud-common/solr"
    # Add the default `entando` core
    curl "http://$NAMESPACE-solr-solrcloud.$KC_AUTH_URL/solr/admin/collections?action=CREATE&name=entando&numShards=1&replicationFactor=3&maxShardsPerNode=2"

  fi
}

if [ -f "$APP_NAME"-cds.check ]; then
  # The primary CDS has already been created so we can start adding all the other configurations:
  # 1. Generate the realm configuration
  genRealmConf
  # 2. Create the new Realm in KC
  newRealm
  # 3. Create the new schemas for the new Tenant
  genNewSchema
  genNewCMSchema
  # 4. Create the ingress for the tenant
  genIngressTenant
  # 5. Create the CDS for the tenant and all the related stuff (secrets)
  genSecondaryCDS
else
  # If the file does not exists, we create it and install the primary CDS
  installSolr
  installRedis
  echo "Redis cluster is installing... "
  sleep 60
  echo "Redis has been installed."
  genPrimaryCDS
  echo "Waiting for the CDS..."
  sleep 30
fi

# Install the CDS
kubectl apply -f "$TENANT"-cds-deployment.yaml
kubectl apply -f "$TENANT"-cds-ingress.yaml
# We can now restart the entando-de-app
kubectl scale deploy "$APP_NAME"-deployment --replicas=1
# check the status of the de-app before scaling up the CM
DE_APP_STATUS_REAL=$(kubectl get deploy $APP_NAME-deployment --no-headers | awk '{print $4}')
DE_APP_STATUS=false
while ! $DE_APP_STATUS
do
    DE_APP_STATUS_REAL=$(kubectl get deploy $APP_NAME-deployment --no-headers | awk '{print $4}')
    if [ $DE_APP_STATUS_REAL -eq 1 ]; then
       DE_APP_STATUS=true
    fi
done

if $DE_APP_STATUS; then
  echo "Scale up the component manager"
  kubectl scale deploy "$APP_NAME"-cm-deployment --replicas=1
fi
